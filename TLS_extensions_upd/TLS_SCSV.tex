\section{Дополнение 1 SCSV}
\subsection{Проблематика}
В стандарте \texttt{СТБ 34.101.65} (в пункте 8.7.2) вводится расширение renegatiation\_info, оно используется для связывания соединения, в котором выполняется переустановка связи, с предыдущим соединением.

 Однако некоторые реализации SSLv3 и TLS 1.0 неправильно завершают рукопожатие в таком случае. Поскольку спецификации TLS 1.1 и ранее требуют игнорировать данные после ClientHello (т.е. расширения), если они их не понимают. Это означает, что клиенты, предлагающие расширение "renegotiation\_info",  могут столкнуться с ошибками в процессе handshake. 
  
\subsection{Решение}
  Из соображений улучшения обрастной совместимости в \texttt{RFC 5746} (пункт 3.3) в сообщении \texttt{client\_hello}  вводится возможность использования специального значения Signaling Cipher Suite Value (SCSV) «TLS\_EMPTY\_RENEGOTIATION\_INFO\_SCSV» с кодовой точкой {0x00, 0xFF}.
 
Этот SCSV не является настоящим криптонабором и не может быть согласован. Вместо этого он имеет ту же семантику, что и у пустого расширения "renegotiation\_info". 
Поскольку реализации SSLv3 и TLS надежно игнорируют неизвестные криптонаборы, SCSV может
быть безопасно отправлен на любой сервер. SCSV также может быть включен в
CLIENT-HELLO, обратно совместимый с SSLv2.

\subsection{Вывод}
Данный механизм полезен, однако существеннен лишь для обратной совместимости с устаревшими серверами. Его использование допускает полное замещение расширения renegotiation\_info на сигнальный криптонабор TLS\_EMPTY\_RENEGOTIATION\_INFO\_SCSV. Кроме того, допустимо и совметсное их использование.




\section{Планованое EMS}

\subsection{Проблематика EMS}
В стандарте \texttt{СТБ 34.101.65} указывается что существует атака "triple handshake". Её суть состоит в том что активный злоумышленник может организовать атаку "человек по середине" (mitm) за счет того что задаст параметры соединения таким образом что \texttt{master\_secret} в обоих сеансах совпадет (полное описание атаки в RFC 7627 пункт 1.). Однако при этом стандарт не определяет механизмов противодействия данной атаке. 

\subsection{Концепт решения }
Решение противодействующее данной атаке предоставляет \texttt{RFC 7626} при помощи расширения \texttt{extended\_master\_secret}. Суть его состоит в изменении вычисления \texttt{master\_secret} таким образом что значение становится зависимых от данных переданных ранее, что не позволит злоумышленнику задать два сеанса с одинаковыми \texttt{master\_secret}.

\subsection{Реальное решение}
Решение: 
Когда происходит полное рукопожатие TLS, мы определяем 
\texttt{session\_hash = Hash(handshake\_messages)}

Где "handshake\_messages" предствляет собой конкатенацию всех отправленных и полученных структур в сообщениях начиная с \texttt{ClientHello} вплоть до \texttt{ClientKeyExchange} включительно, в том числе типы и длины полей этих структур. 
(при этом, для рукопожатий возобновления соединения вычисления не потребуются, так как они не приводят к созданию новой сессии.)

Ранее \texttt{master\_secret} определялся как 
\texttt{master\_secret = PRF(pre\_master\_secret, "master secret",
	ClientHello.random + ServerHello.random)
	[0..47];}

В данном расширении он определяется как:

\texttt{ master\_secret = PRF(pre\_master\_secret, "extended master secret", session\_hash) [0..47];}

При этом "extended master secret" представляет собой то же что и "master secret".

Расширение \texttt{extended\_master\_secret} имеет кодировку в шеснадцатиричном виде 00 17 00 00 (hex).

Данное расширение весьма существенно и должно постоянно применяться на практике.

Для полного протокола handshake:
\begin{itemize}
	\item Клиент поддерживающий данное расширение ДОЛЖЕН отправить расширение "extended\_master\_secret" в сообщении ClientHello. 
	
	Сервер получивший расширение "extended\_master\_secret" и поддерживающий данное расширение ДОЛЖЕН включить расширение "extended\_master\_secret" в его serverHello. 
	
	Таким образом расширение будет согласовано и применено. 
	
	\item 	Если сервер получает clientHello без расширения "extended\_master\_secret", то ему СЛЕДУЕТ разорвать handshake, если он не хочет взаимодействовать с устаревшими
	клиентами. Если он решит продолжить рукопожатие, ему НЕЛЬЗЯ включать расширение в ServerHello.
	
	\item Если клиент получает serverHello без расширения "extended\_master\_secret, то клиенту СЛЕДУЕТ разорвать handshake, если он не хочет взаимодействовать с устаревшим сервером.
	
	\item 	Если клиент и сервер решат продолжать handshake без данного расширения, то они ДОЛЖНЫ использовать стандартное вычисление master\_secret. В таком случае сессия не будет защищена в соответствии с данным расширением. 
	
	
\end{itemize}

Для сокращенного протокола handshake (сервер получает сообщение client hello для сокращенного протокола handshake):

\begin{itemize}
	\item 	Если исходный сеанс не использовал «extended\_master\_secret», но сообщение ClientHello содержит расширение, то сервер ДОЛЖЕН разорвать сокращенный протокол handshake, и СЛЕДУЕТ продолжить полным рукопожатием для согласования нового сеанса.
	
	\item   Если исходный сеанс использовал «extended\_master\_secret», но новое сообщение ClientHello не содержит его, то сервер ДОЛЖЕН прервать сокращенное рукопожатие.
	
	\item Если исходный сеанс не использовал «extended\_master\_secret» и оно отсутствует в ClientHello, то серверу СЛЕДУЕТ разорвать соединение, иначе оно не будет защищено в соответствии с данным расширением.
	
	\item  Если новое сообщение ClientHello содержит данное расширение и сервер
	решает продолжить рукопожатие, тогда сервер ДОЛЖЕН включить
	расширение «extended\_master\_secret» в своем сообщении ServerHello.
\end{itemize}

Для сокращенного протокола handshake (клиент получает сообщение server hello для сокращенного протокола handshake): сокращенный протокол handshake ДОЛЖЕН быть прерван если новое сообщение не соответствует предыдушей сессии относительно расширения "extended\_master\_secret". Если клиент и сервер продолжают процедуру сокращенного handshake, то ключи подключения для нового сеанса они получают стандартным образом.
 
\subsection{Вывод}
Расширение extended\_master\_secret критически важно и ДОЛЖНО использоваться для поддержания должного уровня защищенности соединения.


\section{Планованое E-t-M}

\subsection{Проблематика}
Каноничный подход MAC-then-ENCRYPT, предложенный как в стандарте \texttt{СТБ 34.101.65}, так и в \texttt{RFC 5246} объявляющих TLS 1.2, подвергался множеству атак и кроме того обладал некоторыми неудобствами (как минимум то неудобство, что для проверки корректности сообщения его требовалось сначала расшифровать). В связи с чем возникло и рекомендуется применение иного подхода.

\verbatim
\subsection{Концепт рещения}
В \texttt{RFC 7366} вводится расширение \texttt{encrypt\_then\_mac} которое позволяет согласовать применение данной технологии, что увеличивает надежность протокола. Кроме того вводятся новые механизмы защиты от понижения версии. Так после согласования \texttt{encrypt\_then\_mac} пересогласоваться на отказ от него нельзя. Что приводит к некоторым особенностям работы. Так криптонаборы класса \texttt{AEAD} воспринимаются как не соответствующие MAC-then-ENCRYPT, что не позволит при пересогласовании перейти к данным криптонаборам.

\subsection{Реальное решение}
Идет переход при вычислении от encrypt( data || MAC || pad ) 
к encrypt( data || pad ) || MAC . Где MAC вычисляется на основании всей зашифрованной части. 

Более точно: 

\texttt{
	MAC(MAC\_write\_key, seq\_num +\\
	TLSCipherText.type +\\
	TLSCipherText.version +\\
	TLSCipherText.length +\\
	IV +\\
	ENC(content + padding + padding\_length));
}

а общий пакет данных имеет вид:
\texttt{\\
	struct {\\
		ContentType type;\\
		ProtocolVersion version;\\
		uint16 length;\\
		GenericBlockCipher fragment;\\
		opaque MAC;\\
	} TLSCiphertext;
}

\subsection{Вывод}
Расширение ENCRYPT-then-MAC является важным расширением существенно влияющим на безопасность соединения. Его применение необходимо, в особенности при некоторых криптонаборах уязвимых при MAC-then-ENCRYPT. Стоит так же учитывать существование таких криптонаборов которые не могут сочетаться с использованием данного расширения (такие как криптораборы AEAD). Однако стоит и учитывать что в целом отсутствие данного расширения не обязательно говорит о некоторой уязвимости соединения. Данный вопрос оказывается неотделим от выбора криптонабора. 

\section{Планованое OSCP}

\subsection{Проблематика}
Кроме вопросов безопасности расширения TLS позволяют решать задачи оптимизации процесса установления защищенного соединения. Так одним из факторов некоторого замедления установления соединения можно выделить запрос сертификата сервера. Оптимизировать данный процесс позволяют протоколы OSCP (Online Certificate Status Protocol) позволяющие получать подтверждение корректности сервера сушественно быстрее.

\subsection{Концепт решения}
\texttt{RFC 6066 пункт 8, 6961 } объявляют расширения \texttt{status\_request} и \texttt{status\_request\_v2} позволяющих пользоваться прокотолом OSCP для получения статуса протокола существенно быстрее нежели стандартный запрос протокола и его стандартная проверка. \texttt{status\_request\_v2} концептуально отличается от \texttt{status\_request} тем, что позволяет получать статусы сразу всей цепочки сертификатов. Но основная суть расширения сохраняется.


\subsection{реальное решение для status\_request}
\begin{itemize}
	\item Клиент включает в сообщение client\_hello расширение status\_request.
	\item Сервер МОЖЕТ включить в ответ соответствующий статус сертификата вместе со своим сертификатом.
	
	Если запрашивается OSCP, то серверу СЛЕДУЕТ использовать информацию содержащуюся в расширении для выбора OSCP ответчика и включить request\_extensions в OSCP запрос. 
	\item Сервера в ответ возыращают ответ с свой сертификат и сообщение CertificateStatus. Если сервер(а) возвращает(ют)
	сообщение "CertificateStatus", то сервер ДОЛЖЕН включать
	расширение типа «status\_request» с пустым «extension\_data» в
	extended server hello.
	\item "CertificateStatus" посылается в соответствии с типом "certificate\_status" протокола handshake слудующим образом: 
	
	\texttt{      struct \{
		CertificateStatusType status\_type;\\
		select (status\_type) \{\\
		case ocsp: OCSPResponse;\\
		\} response;\\
		\} CertificateStatus;\\		
		opaque OCSPResponse<$1..2^{24}-1$>;}
	
	
\end{itemize}

\subsection{реальное решение для status\_request\_v2}
Действия как клиента так и сервера для расширения status\_request\_v2 совпадает с поведением при расширении status\_request однако несколько отличаются используемые структуры, а именно:
 struct \{
CertificateStatusType status\_type;
uint16 request\_length; /* Length of request field in bytes */
select (status\_type) \{
case ocsp: OCSPStatusRequest;
case ocsp\_multi: OCSPStatusRequest;
\} request;
\} CertificateStatusRequestItemV2;

enum \{ ocsp(1), ocsp\_multi(2), (255) \} CertificateStatusType;

struct \{
ResponderID responder\_id\_list<0..2\^{}16-1>;
Extensions request\_extensions;
\} OCSPStatusRequest;

opaque ResponderID<1..2\^{}16-1>;
opaque Extensions<0..2\^{}16-1>;

struct \{
CertificateStatusRequestItemV2
certificate\_status\_req\_list<1..2\^{}16-1>;
\} CertificateStatusRequestListV2;

\subsection{Вывод}
Расширения status\_request и status\_request\_v2 являются важными расширениями ускоряющими установление защищенного соединения через поддержание протоколов OSCP. Их использование не повышает уровень защищенности соединения однако все еще является крайне желательным при применении. 

\section{планованое расширение x509v3}

\subsection{проблематика}
Существует целый набор различных атак на TLS и из них можно выделить отдельным классом атаки основанные на том что используются версии протокола где некоторые уязвимости не закрыты. И как не меняй текущий стандарт они закрыты не будут так как уже базируются лишь для устаревших версий. Однако и возможность поддерживать обратную совместимость и доступность устаревших серверов необходимо.

\subsection{Концепт решения}
\texttt{RFC 7633} описывает расширение базирующееся на \texttt{status\_request} и \texttt{status\_request\_v2}. Задача которого обеспечить защиту от атак понижения версии, которые ранее оставались открытыми. 

Данный документ предъявляет требования к виду сертификата, который в себе несет информацию о свойствах сервера которому он предоставляется, что не позволит серверу отказывать в расширениях и функциях которыми он обладает. Таким образом реализуется так же защита от отказа в обслуживании, что позволяет определить что действия сервера являются легитимными и он предоставляет на столько полную защиту на сколько это возможно. 

\subsection{Вывод}
Однако, поскольку данные свойства реализуются через сертификаты, а не силами самого протола TLS, то данное расширение (обновление) не влияет на описание самого протокола и не требует внесения изменений в стандарт.
