\chapter{Протокол Handshake}\label{HANDSHAKE}

\section{Состояние сеанса}\label{HANDSHAKE.1}

Протокол Handshake выполняется поверх протокола 
Record и отвечает за установку, возобновление или 
переустановку связи. При установке связи создается новый сеанс. Сеанс 
описывается состоянием со следующими элементами: 
%
\begin{itemize}
\item[--]
идентификатор сеанса~--- произвольная строка байтов, выбираемая 
сервером для идентификации активного (текущего) или возобновляемого 
сеанса; 

\item[--]
сертификат стороны~--- сертификат открытого ключа стороны. Формат 
сертификата должен соответствовать СТБ~34.101.19. Этот элемент состояния 
может отсутствовать;
 
\item[--]
алгоритм сжатия;

\item[--]
криптоопределение;

\item[--]
мастер-ключ~--- секретная строка из 48 байтов, общая для клиента и сервера;

\item[--]
флаг возобновления~--- признак, который определяет, может ли сеанс 
использоваться для создания по нему новых состояний соединения. 
\end{itemize}

По состоянию сеанса создаются параметры защиты, по которым затем 
формируются состояния соединения. Эти состояния используются протоколом 
Record при защите данных прикладных протоколов. Благодаря наличию в 
протоколе Handshake механизмов возобновления и переустановки связи, с 
использованием одного и того же сеанса может быть установлено множество 
соединений. 

\section{Шаги протокола}\label{HANDSHAKE.2}

При установке связи клиент и сервер согласуют версию TLS, выбирают 
криптографические алгоритмы, проводят аутентификацию друг друга (при 
необходимости), формируют общий секретный ключ. При установке связи 
протокол Handshake состоит из следующих этапов: 

\begin{itemize}
\item[--] 
обмен приветственными сообщениями с целью согласования алгоритмов 
шифрования, передачи случайных данных, проверки возобновляемости сеанса; 

\item[--] 
обмен необходимыми криптографическими параметрами для 
согласования клиентом и сервером предварительного 
мастер-ключа~\lstinline{pre_master_secret};  

\item[--]
обмен сертификатами и другими данными для взаимной аутентификации клиента 
и сервера (при необходимости); 

\item[--]
выработка мастер-ключа \lstinline{master_secret} с использованием 
\lstinline{pre_master_secret} и случайных данных, которыми обменялись  
клиент и сервер; 

\item[--]
передача параметров защиты протоколу~Record;

\item[--]
проверка того, что противоположная сторона вычислила те же параметры 
защиты, и что сеанс создан без вмешательства злоумышленника. 
\end{itemize}

Протоколам, выполняемым поверх TLS, не следует полностью полагаться на то, 
что стороны согласуют наиболее надежный для них способ соединения. 
Злоумышленник может провести атаку типа <<человек посередине>> и навязать 
обеим сторонам наименее безопасный способ связи из тех, которые они могут 
поддержать. TLS сводит риск таких атак к минимуму, но тем не менее атаки 
возможны. Например, злоумышленник может заблокировать доступ к 
коммуникационному порту, который соответствует TLS, или заставить стороны 
взаимодействовать без TLS. Для протоколов верхних уровней должен быть 
определен необходимый уровень безопасности, эти протоколы не должны 
передавать информацию по каналам связи менее безопасным способом, чем 
необходимо. TLS безопасен в том смысле, что каждый криптонабор 
предоставляет заявленный уровень защиты. 

Этапы протокола~Handshake детализируются следующим образом 
(содержание и значение каждого сообщения определяются в следующих 
подразделах). 

Клиент отправляет сообщение~\lstinline{ClientHello}, на которое сервер 
должен ответить сообщением~\lstinline{ServerHello}. Если ответ от сервера 
не получен, то генерируется ошибка и соединение не устанавливается. 
Сообщения~\lstinline{ClientHello} и~\lstinline{ServerHello} используются 
для выбора наиболее безопасного из возможных способов связи между клиентом 
и сервером.

С помощью сообщений \lstinline{ClientHello} и \lstinline{ServerHello} 
согласуются следующие параметры связи: версия протокола, идентификатор 
сеанса, криптонабор и алгоритм сжатия. Дополнительно с помощью данных 
сообщений стороны обмениваются случайными данными клиента 
\lstinline{ClientHello.random} и сервера \lstinline{ServerHello.random}. 

Для формирования общего ключа используется до четырех сообщений: сообщения 
сервера \lstinline{Certificate}, \lstinline{ServerKeyExchange} и сообщения 
клиента \lstinline{Certificate}, \lstinline{ClientKeyExchange}. TLS 
допускает разработку новых алгоритмов формирования общего ключа путем 
определения форматов указанных сообщений и правил их обработки. Общий ключ 
ДОЛЖЕН быть достаточно длинным, рекомендуется использовать ключ длиной не 
менее 48~байтов.  

Если сервер должен быть аутентифицирован, то следом за приветственными
сообщениями он отправляет свой сертификат в сообщении
\lstinline{Certificate}. Дополнительно, если требуется, может быть
отправлено сообщение \lstinline{ServerKeyExchange} (например, если сервер
не имеет сертификата или его сертификат содержит только открытый ключ ЭЦП).
Сервер может потребовать сертификат от клиента, если сервер
аутентифицируется и если запрос сертификата предусмотрен выбранным
криптонабором. Сервер отправляет сообщение \lstinline{ServerHelloDone},
указывающее на то, что фаза обмена приветственными сообщениями закончена, и
ждет ответа клиента. Если сервер отправил сообщение
\lstinline{CertificateRequest}, то клиент ДОЛЖЕН отправить сообщение
\lstinline{Certificate}, а затем сообщение \lstinline{ClientKeyExchange}.
Содержание сообщения \lstinline{ClientKeyExchange} зависит от алгоритма с
открытым ключом, который был выбран при обмене сообщениями
\lstinline{ClientHello} и \lstinline{ServerHello}. Если клиент послал
сертификат открытого ключа, который может использоваться для проверки ЭЦП,
то отправляется сообщение \lstinline{CertificateVerify} с атрибутом
\lstinline{digitally-signed}. Это сообщение отправляется для того, чтобы
доказать владение личным ключом, соответствующим открытому ключу
сертификата.

После выполнения описанных действий клиент отправляет сообщение
\lstinline{ChangeCipherSpec} и переводит ожидаемое состояние записи
соединения, содержащее согласованное криптоопределение, в текущее. Сразу
после этого клиент посылает сообщение \lstinline{Finished}, защищенное с
помощью алгоритмов и ключей из нового криптоопределения. В ответ сервер
выполняет аналогичные действия: отправляет свое сообщение
\lstinline{ChangeCipherSpec}, переводит свое ожидаемое состояние записи в
текущее и посылает свое сообщение \lstinline{Finished}, защищенное с
использованием согласованного криптоопределения. При получении
\lstinline{ChangeCipherSpec} стороны переводят свои ожидаемые состояния
чтения в текущие. Стороны проверяют сообщения \lstinline{Finished} и на
этом установка связи завершается.

После установки связи клиент и сервер могут начать обмен данными прикладных
протоколов. На рисунке~\ref{Fig.Handshake.1} изображен полный обмен
сообщениями при установке связи. Звездочкой помечены необязательные
сообщения, символом <<+>>~--- сообщения, связанные с аутентификацией
клиента. Сообщения \lstinline{ChangeCipherSpec}, выделенные квадратными
скобками, не относятся к протоколу Handshake.

\begin{figure}[bht]
\begin{center}
\begin{tabular}{lcr}
\hline
клиент  & \hspace{3cm} & сервер \\
\hline
\lstinline|ClientHello| & $\to$   &\\
\hline
	                    & 	      & \lstinline|ServerHello|\\
                        &         & \lstinline|Certificate|*\\ 
                        & $\gets$ & \lstinline|ServerKeyExchange|*\\ 
                        &  	      & \lstinline|CertificateRequest|*+\\ 
                        &  	      & \lstinline|ServerHelloDone|\\ 
\hline
\lstinline|Certificate|*        &       &\\ 
\lstinline|ClientKeyExchange|   & 		&\\ 
\lstinline|CertificateVerify|*+ & $\to$ &\\
\lstinline|[ChangeCipherSpec]|  &       &\\
\lstinline|Finished|            &       &\\ 
\hline
                       & $\gets$& \lstinline|[ChangeCipherSpec]|\\
                       &        & \lstinline|Finished|\\
\hline
[Данные прикладного протокола]  & 	$\leftrightarrow$	& 
[Данные прикладного протокола] \\
\hline
\end{tabular}     
\end{center}
\caption{Полный обмен сообщениями протокола Handshake}\label{Fig.Handshake.1}
\end{figure}

Данные прикладных протоколов НЕЛЬЗЯ посылать до того, как завершится 
установка связи (т.~е. до того, как будет согласован и применен 
криптонабор, отличный от \lstinline{TLS_NULL_WITH_NULL_NULL}). 

Когда клиент и сервер решают возобновить или переустановить связь, 
используя параметры уже существующего сеанса (вместо того, чтобы 
согласовывать новые параметры), выполняется сокращенный обмен 
сообщениями.  

Клиент отправляет сообщение \lstinline{ClientHello}, в котором указывает
идентификатор сеанса, который должен использоваться для возобновления связи. 
При получении данного сообщения сервер проверяет список сеансов, которые 
были созданы ранее (кэш сеансов), и ищет сеанс с присланным 
идентификатором. Если совпадение найдено, и сервер желает возобновить 
связь, используя найденный сеанс, то он отправляет сообщение 
\lstinline{ServerHello} с тем же самым идентификатором сеанса. После этого 
клиент и сервер ДОЛЖНЫ отправить сообщения \lstinline{ChangeCipherSpec} и 
перейти к пересылке сообщений \lstinline{Finished}. На 
рисунке~\ref{Fig.Handshake.2} изображен сокращенный обмен сообщениями 
между клиентом и сервером при возобновлении связи. Аналогичный обмен 
выполняется при переустановке связи.

Если сервер не нашел сеанс с нужным идентификатором, то он генерирует 
новое значение идентификатора. После чего клиент и сервер выполняют полный 
обмен сообщениями по протоколу~Handshake.

\begin{figure}[!h]
\begin{center}
\begin{tabular}{lcr}
\hline
клиент  & \hspace{3cm} & сервер \\
\hline
\lstinline|ClientHello|	& $\to$     &\\
\hline                              
	                    &           &\lstinline|ServerHello|\\
                        &  $\gets$  &\lstinline|[ChangeCipherSpec]|\\
                        &           &\lstinline|Finished|\\
\hline
\lstinline|[ChangeCipherSpec]| & $\to$ &\\
\lstinline|Finished|           &       &\\
\hline
[Данные прикладного протокола]	& $\leftrightarrow$ &	
[Данные прикладного протокола] \\
\hline
\end{tabular}
\end{center}
\caption{Сокращенный обмен сообщениями протокола Handshake}\label{Fig.Handshake.2}
\end{figure}

\section{Сообщения протокола}\label{HANDSHAKE.3}

Сообщения протокола Handshake передаются протоколу~Record, который 
помещает их в одну или более структур \lstinline{TLSPlaintext}. 
Данные структуры обрабатываются и передаются в соответствии с текущим 
активным состоянием сеанса. 

Сообщения протокола~Handshake определяются следующим образом:
\begin{lstlisting}
struct {
  HandshakeType msg_type;
  uint24 length;
  select (HandshakeType) {
    case hello_request:       HelloRequest;
    case client_hello:        ClientHello;
    case server_hello:        ServerHello;
    case certificate:         Certificate;
    case server_key_exchange: ServerKeyExchange;
    case certificate_request: CertificateRequest;
    case server_hello_done:   ServerHelloDone;
    case certificate_verify:  CertificateVerify;
    case client_key_exchange: ClientKeyExchange;
    case finished:            Finished;
  } body;
} Handshake;
enum {
  hello_request(0), client_hello(1), server_hello(2),
  certificate(11), server_key_exchange(12),
  certificate_request(13), server_hello_done(14),
  certificate_verify(15), client_key_exchange(16),
  finished(20), (255)
} HandshakeType;
\end{lstlisting}

Поля структуры \lstinline{Handshake} имеют следующее значение:
\begin{itemize}
\item[--]
\lstinline{msg_type}~--- тип сообщения, который описывается 
перечислением \lstinline{HandshakeType}. Элементы этого перечисления 
соответствуют сообщениям, определенным в~\ref{HANDSHAKE.4}~--- \ref{HANDSHAKE.15}; 

\item[--]
\lstinline{length}~--- длина в байтах поля \lstinline{Handshake.body};

\item[--]
\lstinline{body}~--- тело сообщения.
\end{itemize}

Сообщения протокола Handshake определяются в следующих подразделах в 
порядке, в котором они ДОЛЖНЫ отправляться. Отправка сообщений в порядке, 
который не предусмотрен настоящим стандартом, приводит к ошибке. Ненужные 
сообщения могут быть пропущены. Сообщение \lstinline{HelloRequest} не подчиняется 
данному порядку следования: оно может быть отправлено в любое время, но 
клиенту СЛЕДУЕТ его игнорировать, если оно приходит во время установки 
связи. 

Сообщения \lstinline{HelloRequest}, \lstinline{ClientHello},
\lstinline{ServerHello} являются приветственными. Эти сообщения
используются для выбора наиболее безопасного из возможных способов связи
между клиентом и сервером. Когда создается новый сеанс, в состояниях
соединения заданы <<пустые>> алгоритмы сжатия, шифрования и имитозащиты.
Эти алгоритмы используются для обработки сообщений вплоть до согласования
новых алгоритмов.

\section{Сообщение \lstinline{HelloRequest}}\label{HANDSHAKE.4}

Сообщение \lstinline{HelloRequest} сервер МОЖЕТ отправить в любое время.
Данное сообщение сообщает клиенту, что он должен снова начать согласование
параметров связи. В ответ на сообщение \lstinline{HelloRequest} клиент,
если посчитает нужным, должен отправить сообщение \lstinline{ClientHello}.
Сообщение \lstinline{HelloRequest} не предназначено для того, чтобы
определить, какая из сторон является клиентом, а какая~--- сервером. Серверу
НЕ СЛЕДУЕТ отправлять сообщение сразу после того, как клиент инициировал
соединение (отправил сообщение \lstinline{ClientHello}).

Клиенту следует игнорировать сообщение \lstinline{HelloRequest}, если в
момент его получения он уже находится в процессе установки связи. Клиент
МОЖЕТ проигнорировать сообщение, если он не желает переустанавливать связь.
Клиент также может ответить сигнальным сообщением
\lstinline{no_renegotiation} (см.~\ref{ALERT.3}).

Между отправкой \lstinline{HelloRequest}  и получением
\lstinline{ClientHello} серверу могут приходить от клиента фрагменты данных
прикладных протоколов. Ожидается, что сервер получит только малое число
таких фрагментов, поскольку сообщения протокола Handshake при
пересылке имеют приоритет над данными прикладных протоколов. Если сервер
отправляет \lstinline{HelloRequest}, но не получает в ответ
\lstinline{ClientHello}, то он может закрыть соединение с критическим
сигнальным сообщением.

После отправки сообщения \lstinline{HelloRequest}, серверу НЕ СЛЕДУЕТ
повторять запрос до тех пор, пока не завершится последующий обмен
сообщениями протокола Handshake.

Сообщение \lstinline{HelloRequest} имеет следующую структуру:

\begin{lstlisting}
struct {} HelloRequest;
\end{lstlisting}

Это сообщение НЕ ДОЛЖНО учитываться при вычислении хэш-значений, 
используемых в сообщениях \lstinline{Finished} и 
\lstinline{CertificateVerify}. 

\section{Сообщение \lstinline{ClientHello}}\label{HANDSHAKE.5}

Клиент посылает сообщение \lstinline{ClientHello} при установке связи
(полной или сокращенной).
Клиент также может послать это сообщение после установки связи либо в ответ
на сообщение \lstinline{HelloRequest}, либо по собственной инициативе с
целью переустановки связи.

Сообщение \lstinline{ClientHello} определяется следующим образом:
\begin{lstlisting}
struct {
  ProtocolVersion client_version;
  Random random;
  SessionID session_id;
  CipherSuite cipher_suites<2..2^16-2>;
  CompressionMethod compression_methods<1..2^8-1>;
  select (extensions_present) {
    case false:
      struct {};
    case true:
      Extension extensions<0..2^16-1>;
  };
} ClientHello;
struct {
  uint32 gmt_unix_time;
  opaque random_bytes[28];
} Random;
opaque SessionID<0..32>;
\end{lstlisting}

Поля структуры \lstinline{ClientHello} имеют следующее значение:
\begin{itemize}
\item[--]
\lstinline{client_version}~--- версия TLS, которую клиент 
предлагает использовать в течение сеанса. Тип данного поля определен 
в~\ref{RECORD.3.1}; 

\item[--]
\lstinline{random}~--- структура со случайными данными, сгенерированными клиентом;

\item[--]
\lstinline{session_id}~--- идентификатор сеанса, параметры защиты которого клиент 
предлагает использовать в данном соединении. В этом поле задается пустая 
строка, если клиент желает создать новый сеанс. Непустая строка может 
соответствовать идентификатору, использованному в 1)~соединении, которое 
было закрыто, 2)~текущем соединении, 3)~другом активном в настоящее время 
соединении. Второй вариант приводит только к обновлению поля 
\lstinline{random} и производных от него параметров соединения. Третий 
вариант позволяет установить несколько независимых безопасных соединений 
по сокращенной схеме обмена сообщениями протокола Handshake (эти 
независимые соединения  могут устанавливаться последовательно или 
одновременно);

\item[--]
\lstinline{cipher_suites}~--- список идентификаторов криптонаборов, 
поддерживаемых клиентом. Список упорядочивается клиентом в порядке 
убывания приоритета. Если поле \lstinline{session_id} не пустое 
(подразумевается запрос на возобновление или переустановку связи), 
то список ДОЛЖЕН содержать криптонабор
\lstinline{ServerHello.cipher_suite}, согласованный в сеансе с
идентификатором \lstinline{session_id}. Сервер выбирает криптонабор из
полученного списка или, если отсутствуют приемлемые для него варианты,
отправляет критическое  сигнальное сообщение \lstinline{handshake_failure}
(см.~\ref{ALERT.3}) и закрывает соединение.  Если список содержит
криптонаборы, которые сервер не распознает, не поддерживает или не желает
использовать, то он ДОЛЖЕН проигнорировать эти криптонаборы, а оставшиеся
криптонаборы обработать обычным образом;

\item[--]
\lstinline{compression_methods}~--- список поддерживаемых клиентом 
алгоритмов сжатия, упорядоченный клиентом в порядке убывания приоритета. 
Тип данного поля определен в~\ref{RECORD.2}. Если поле 
\lstinline{session_id} не пустое, то список ДОЛЖЕН содержать 
алгоритм \lstinline{ServerHello}.\lstinline{compression_method}, 
согласованный в сеансе с идентификатором \lstinline{session_id}. 
Список ДОЛЖЕН содержать и все реализации ДОЛЖНЫ поддерживать алгоритм 
\lstinline{CompressionMethod.null}. Это позволит клиенту   
и серверу всегда согласовать алгоритм сжатия; 

\item[--]
\lstinline{extensions}~--- список расширений, которые клиенты МОГУТ 
отправить серверу для согласования дополнительных функциональных 
возможностей. Тип данного поля определен в~\ref{HANDSHAKE.7}. 
\end{itemize}

Поля структуры \lstinline{Random} имеют следующее значение:
\begin{itemize}
\item[--]
\lstinline{gmt_unix_time}~--- текущее время и дата согласно таймеру 
отправителя в стандартном формате UNIX (т.~е. количество секунд, прошедших 
начиная с 0 часов 1 января 1970 года в стандартном времени по Гринвичу, 
игнорируя секунды координации). TLS не требует корректной установки 
таймера (прикладные протоколы или протоколы более высокого уровня могут 
определять дополнительные требования); 

\item[--]
\lstinline{random_bytes}~--- 28 байтов, сгенерированных с помощью 
криптографически стойкого генератора случайных или псевдослучайных чисел. 
\end{itemize}

Идентификатор сеанса становится действительным, когда протокол
Handshake завершается сообщениями \lstinline{Finished}, и
сохраняется до тех пор, пока не будет удален по истечении срока хранения
состояния сеанса или из-за ошибки в соединении, связанном с данным сеансом.
Фактическое значение идентификатора сеанса определяется сервером.

Так как идентификатор сеанса передается в незашифрованном виде, сервер НЕ
ДОЛЖЕН помещать в идентификатор конфиденциальную информацию. Целостность
идентификатора контролируется отложенно (при обработке
\lstinline{Finished}), поэтому стороны должны корректно обрабатывать любые,
даже заведомо неверные идентификаторы, которые может посылать
злоумышленник.

Сообщения \lstinline{ClientHello} могут содержать расширения. Для проверки наличия 
расширений следует проверить, что сообщение не заканчивается полем 
\lstinline{compression_methods} и что за этим полем имеются дополнительные байты. 
Такой метод выявления необязательных данных отличается от обычного в TLS 
способа обработки полей переменной длины. Метод выбран для совместимости с 
более ранними версиями TLS, в которых расширения не были предусмотрены. 
 
Если клиент, используя \lstinline{extensions}, запрашивает дополнительные
функциональные возможности и эти функциональные возможности сервер не
поддерживает, клиент МОЖЕТ аварийно прекратить установку связи. Сервер
ДОЛЖЕН принимать сообщение \lstinline{ClientHello} как с полем
\lstinline{extensions}, так и без него. При этом он ДОЛЖЕН проверить (как и
для всех других сообщений), что объем данных в сообщении точно совпадает с
объемом данных, определяемых форматом сообщения. Если объемы данных не
совпадают, то сервер ДОЛЖЕН отправить критическое сигнальное сообщение
\lstinline{decode_error} (см.~\ref{ALERT.3}).

После отправки сообщения \lstinline{ClientHello} клиент ожидает получения
сообщения сервера \lstinline{ServerHello}. Отправка сервером любого другого
сообщение протокола Handshake, за исключением сообщения
\lstinline{HelloRequest}, рассматривается как ошибка.

\section{Сообщение \lstinline{ServerHello}}\label{HANDSHAKE.6}

Сообщение \lstinline{ServerHello} отправляется сервером в ответ на сообщение 
\lstinline{ClientHello}, когда он может выбрать из предложенного клиентом списка 
приемлемый для него криптонабор. Если сервер не может выбрать такой 
криптонабор, то он отправляет критическое сигнальное сообщение 
\lstinline{handshake_failure} (см.~\ref{ALERT.3}). 

Сообщение \lstinline{ServerHello} определяется следующим образом:
\begin{lstlisting}
struct {
  ProtocolVersion server_version;
  Random random;
  SessionID session_id;
  CipherSuite cipher_suite;
  CompressionMethod compression_method;
  select (extensions_present) {
    case false:
      struct {};
    case true:
      Extension extensions<0..2^16-1>;
  };
} ServerHello;
\end{lstlisting}

Поля структуры \lstinline{ServerHello} имеют следующее значение:
\begin{itemize}
\item[--]
\lstinline{server_version}~--- поле содержит согласованную между 
клиентом и сервером версию TLS. Тип данного поля определен в~\ref{RECORD.3.1}; 

\item[--]
\lstinline{random}~--- поле со случайными данными, сгенерированными 
сервером. Тип данного поля определен в~\ref{HANDSHAKE.5}. Случайные данные 
ДОЛЖНЫ генерироваться независимо от \lstinline{ClientHello.random}; 

\item[--]
\lstinline{session_id}~--- идентификатор сеанса, соответствующего 
данному соединению. Если поле \lstinline{session_id} в сообщении 
\lstinline{ClientHello} не было пустым, то сервер ищет присланный 
идентификатор в кэше сеансов. Если сеанс с нужным идентификатором найден, 
и сервер желает установить связь, используя состояние этого сеанса, то он 
отвечает тем же идентификатором, который был прислан клиентом. Этот ответ 
сервера указывает на возобновление связи и требует от сторон 
перехода сразу к сообщениям~\lstinline{Finished}. В противном случае поле 
\lstinline{session_id} должно содержать значение, соответствующее новому 
сеансу. Сервер может вернуть пустое поле~\lstinline{session_id}, чтобы 
указать на то, что сеанс не будет кэшироваться и не может 
использоваться для возобновления связи в будущем. При возобновлении
связи должен использоваться тот самый криптонабор, который был  
согласован ранее. От сервера не требуется возобновлять связь, даже если 
сеанс с нужным идентификатором имеется в кэше. Клиенты ДОЛЖНЫ быть готовы 
выполнить полное согласование параметров связи 
(включая согласование криптонаборов) всякий раз при запросе на 
возобновление связи; 

\item[--]
\lstinline{cipher_suite}~--- идентификатор криптонабора, который 
сервер выбрал из списка, переданного клиентом в поле 
\lstinline{ClientHello.cipher_suites}. При возобновлении связи сервер не 
выбирает криптонабор, а задает его по сохраненному состоянию сеанса; 
 
\item[--]
\lstinline{compression_method}~--- алгоритм сжатия, который сервер 
выбрал из списка, переданного клиентом в поле 
\lstinline{ClientHello.compression_methods}. При возобновлении связи 
сервер не выбирает алгоритм, а задает его по сохраненному состоянию 
сеанса; 

\item[--]
\lstinline{extensions}~--- список расширений. Только расширения, 
предложенные клиентом, могут включаться в список сервера. Признаком 
передачи расширений является наличие байтов за полем 
\lstinline{compression_method} (см.~\ref{HANDSHAKE.5}). 
\end{itemize}

Определенные выше правила возобновления связи 
действуют также при переустановке связи. 

\section{Расширения приветственных сообщений}\label{HANDSHAKE.7}

Расширения приветственных сообщений описываются следующим типом:
\begin{lstlisting}
struct {
  ExtensionType extension_type;
  opaque extension_data<0..2^16-1>;
} Extension;
\end{lstlisting}

Поля структуры \lstinline{Extension} имеют следующее значение:
\begin{itemize}
\item[--]
\lstinline{extension_type}~--- тип расширения;

\item[--]
\lstinline{extension_data}~--- данные расширения, т.~е. информация, 
специфическая для конкретного типа расширения. 
\end{itemize}

Вложенный тип \lstinline{ExtensionType} определяется следующим образом:
\begin{lstlisting}
enum {
  signature_algorithms(13), renegotiation_info(65281), (65535)
} ExtensionType;
\end{lstlisting}

\begin{note*}
Некоторые распространенные дополнительные расширения определены 
в~\cite{RFC6066}.
\end{note*} 

В сообщение \lstinline{ServerHello} НЕЛЬЗЯ включать расширения с типом,
который не встречается в соответствующем сообщении \lstinline{ClientHello}.
Если клиент получает в \mbox{\lstinline{ServerHello} расширения} с типом, который
не был указан в соответствующем \lstinline{ClientHello}, то он ДОЛЖЕН
прервать установку связи с сигнальным сообщением
\lstinline{unsupported_extension} (см.~\ref{ALERT.3}). Тем не менее
предусмотрена возможность использования расширений, ориентированных на
отправку сервером. Такие расширения с пустым полем
\lstinline{extension_data} клиент посылает серверу в сообщении
\lstinline{ClientHello}. Этим клиент демонстрирует серверу, что он может
обрабатывать расширение данного типа. В ответ на сообщение клиента сервер
высылает расширение того же типа, но уже с заполненными данными.При
реализации TLS следует учитывать, что в сообщениях \lstinline{ClientHello},
\lstinline{ServerHello} расширения различных типов МОГУТ встречаться в
любом порядке. Расширения одного типа НЕЛЬЗЯ включать в список более одного
раза.

Расширение может посылаться и при установке связи, и при ее возобновлении. 
Необходимость отправки расширения при возобновлении связи объясняется тем, 
что клиент, который запрашивает возобновление, не знает наверняка, примет 
ли сервер запрос на возобновление или нет. Следовательно, клиенту СЛЕДУЕТ 
отправить серверу те же расширения, какие бы он послал, если бы начинал 
новый сеанс. 

В общем случае, при описании каждого расширения требуется определить способ
его обработки как при полном, так и при сокращенном обмене сообщениями
протокола Handshake. С другой стороны, большинство используемых
расширений TLS применяются только при установке связи. При возобновлении
связи сервер не обрабатывает такие расширения, даже если они присутствуют в
сообщении \lstinline{ClientHello}, и не включает их в сообщение
\lstinline{ServerHello}.

При разработке новых расширений необходимо учитывать следующее:
\begin{itemize}
\item[--] 
сервер может отказаться обрабатывать расширение как из-за ошибки, 
так и ввиду отсутствия необходимости поддерживать определенные 
функциональные возможности. В первом случае следует использовать 
сигнальные сообщения об ошибке. Во втором случае серверу следует объяснить 
отказ в поле \lstinline{extension_data}; 

\item[--]
расширения должны, по возможности, разрабатываться так, чтобы 
предотвращать атаку, которая навязывает использование (или наоборот 
отключает) определенные функциональные возможности путем манипуляции 
сообщениями протокола Handshake. Подлинность сообщений протокола 
Handshake, в том числе подлинность расширений, контролируется при 
обработке \lstinline{Finished}. Тем не менее необходимо 
уделять особое внимание случаям, когда расширение изменяет смысл 
сообщений, посылаемых при установке связи. Пока установка связи не 
завершена, злоумышленник может модифицировать сообщения и вставить, 
удалить или переместить расширения;  

\item[--]
существует техническая возможность использовать расширения для 
изменения базовых конструктивных схем протокола TLS, например, схемы 
согласования криптонабора. Поддерживать изменение базовых схем не 
рекомендуется. Более подходящим будет определить новую версию TLS. 
\end{itemize}

\subsection{Расширение \lstinline{signature_algorithms}}\label{HANDSHAKE.7.1}

Клиент использует расширение с типом \lstinline{signature_algorithms},
чтобы указать серверу, какие пары <<алгоритм хэширования, алгоритмы ЭЦП>>
могут использоваться при выработке и проверке ЭЦП. Поле
\lstinline{extension_data} этого расширения содержит значение
\lstinline{supported_signature_algorithms}, которое является списком с
элементами типа \lstinline{SignatureAndHashAlgorithm}:
\begin{lstlisting}
SignatureAndHashAlgorithm supported_signature_algorithms<2..2^16-2>;
\end{lstlisting}

Элементы в списке указываются в порядке убывания приоритета.
 
Если клиент поддерживает только определенную пару <<алгоритм хэширования, 
алгоритмы ЭЦП>>, которая по умолчанию используется вместе с согласуемыми 
криптонаборами, то он МОЖЕТ опустить расширение \lstinline{signature_algorithms}. 
Если клиент не поддерживает пару по умолчанию или поддерживает другие пары 
(и намеревается их использовать для проверки сообщений сервера, т.~е. для 
проверки сертификатов и подписи в~\lstinline{ServerKeyExchange}), 
то клиент ДОЛЖЕН выслать расширение~\lstinline{signature_algorithms}, 
перечислив поддерживаемые пары.  

Серверам НЕЛЬЗЯ посылать расширение с типом~\lstinline{signature_algorithms}. 
Серверы ДОЛЖНЫ поддерживать получение этого расширения. 

Когда выполняется возобновление сеанса, расширение с 
типом~\lstinline{signature_algorithms} не включается в 
сообщение~\lstinline{ServerHello} и сервер игнорирует данное расширение в 
сообщении~\lstinline{ClientHello}.   

\subsection{Расширение~\lstinline{renegotiation_info}}\label{HANDSHAKE.7.2}

Расширение с типом~\lstinline{renegotiation_info} используется для связывания 
соединения, в котором выполняется переустановка связи, с предыдущим 
соединением. Такое связывание защищает от атак, в которых злоумышленник 
сначала устанавливает связь с сервером, а затем инициирует переустановку 
связи и передает выполнение протокола клиенту. По завершении атаки между 
клиентом и сервером устанавливается обычное защищенное соединение, но 
сервер ошибочно считает, что оно является продолжением предыдущего 
соединения, которое было установлено со злоумышленником. 

Если клиент и сервер хотят использовать механизм переустановки связи, то 
они ДОЛЖНЫ хранить три дополнительных параметра соединения: 
\begin{itemize}
\item[--]
\lstinline{secure_renegotiation}~--- флаг того, что поддерживается 
переустановка связи;

\item[--]
\lstinline{client_verify_data}~--- поле \lstinline{verify_data} 
сообщения \lstinline{Finished}, которое было выслано клиентом по 
завершении предыдущего сеанса протокола Handshake; 

\item[--]
\lstinline{server_verify_data}~--- поле \lstinline{verify_data} 
сообщения \lstinline{Finished}, которое было выслано сервером по 
завершении предыдущего сеанса протокола Handshake. 
\end{itemize}

Эти параметры касаются соединения в целом (в обоих направлениях). Параметры 
не относятся к сеансу, и поэтому их не требуется сохранять в кэше сеансов. 

Содержимое расширения описывается следующим образом:
\begin{lstlisting}
struct {
  opaque renegotiated_connection<0..255>;
} RenegotiationInfo;
\end{lstlisting}
                
При установке связи поле \lstinline{renegotiated_connection}
устанавливается пустым как в сообщении \lstinline{ClientHello}, так и в
сообщении \lstinline{ServerHello}. При переустановке связи поле
устанавливается равным \lstinline{client_verify_data} (12 байтов) в
сообщении \lstinline{ClientHello} и 
\lstinline{client_verify_data + server_verify_data} (24 байта) 
в сообщении \lstinline{ServerHello}.

{\bf Действия клиента при установке связи}. 
Если клиент собирается переустанавливать связь, то при установке связи 
(полной или сокращенной) он ДОЛЖЕН включить расширение 
\lstinline{renegotiation_info} с пустым содержимым в свое сообщение 
\lstinline{ClientHello}. После получения сообщения \lstinline{ServerHello} 
от сервера клиент ДОЛЖЕН проверить, что это сообщение включает расширение 
\lstinline{renegotiation_info}. 
%
Отсутствие расширения означает, что сервер не поддерживает безопасную 
переустановку связи. Если расширение отсутствует, то клиент должен сбросить 
флаг~\lstinline{secure_renegotiation} в~0. Более того, клиент может 
разорвать связь, если безопасная переустановка является для него критичной.

\begin{note*}
Здесь и далее в параграфе разрыв связи означает отправку сигнального сообщения
\lstinline{handshake_failure} с последующим закрытием соединения.
\end{note*} 

Если расширение присутствует, то клиент устанавливает флаг 
\lstinline{secure_renegotiation} в~1. Клиент ДОЛЖЕН проверить, что длина поля 
\lstinline{renegotiated_connection} равняется~0. Если последнее условие 
нарушается, то клиент ДОЛЖЕН разорвать связь. 

После установки связи клиент должен сохранить атрибуты 
\lstinline{client_verify_data} и \lstinline{server_verify_data}. 

{\bf Действия клиента при переустановке связи}. 
При переустановке связи клиент проверяет значение флага 
\lstinline{secure_renegotiation}. Если флаг равняется~0, то клиент не должен 
инициировать переустановку. Если флаг
равняется~0 и переустановку инициировал сервер, то клиенту РЕКОМЕНДУЕТСЯ
отвергнуть ее. При этом клиент ДОЛЖЕН выслать предупредительное сигнальное
сообщение \lstinline{no_renegotiate}.

Если флаг равняется 1, то клиент может переустанавливать связь. Клиент
включает расширение \lstinline{renegotiation_info} в свое сообщение
\lstinline{ClientHello}. В содержимом расширения должна передаваться строка
\lstinline{client_verify_data}. После получения сообщения
\lstinline{ServerHello} клиент ДОЛЖЕН проверить, что расширение
\lstinline{renegotiation_info} в нем присутствует, первая половина поля
\lstinline{renegotiated_connection} совпадает с сохраненным значением
\lstinline{client_verify_data}, а вторая половина совпадает с сохраненным
значением \lstinline{server_verify_data}. При нарушении любого из этих
условий клиент ДОЛЖЕН прервать переустановку связи.

После переустановки связи клиент должен сохранить новые 
значения \lstinline{client_verify_data} и \lstinline{server_verify_data}. 

{\bf Действия сервера при установке связи}. 
При установке связи (полной или сокращенной) сервер ДОЛЖЕН проверить, что
сообщение \lstinline{ClientHello} включает расширение
\lstinline{renegotiation_info}. Отсутствие расширения означает, что клиент
не поддерживает безопасную переустановку связи. 
Если расширение отсутствует, то сервер должен сбросить флаг
\lstinline{secure_renegotiation} в 0. Более того, сервер может разорвать 
связь, если безопасная переустановка является для него критичной.

Если расширение \lstinline{renegotiation_info} включено в
\lstinline{ClientHello}, то сервер проверяет, что его содержимое является
пустым. При нарушении этого условия сервер ДОЛЖЕН разорвать связь. 
Если содержимое расширения пусто, то сервер
устанавливает флаг \lstinline{secure_renegotiation} в 1 и возвращает 
такое же пустое расширение в своем сообщении \lstinline{ServerHello}.

После установки связи сервер должен сохранить атрибуты 
\lstinline{client_verify_data} и \lstinline{server_verify_data}. 

{\bf Действия сервера при переустановке связи}. 
При переустановке связи клиент
проверяет значение флага \lstinline{secure_renegotiation}. Если флаг
равняется~0, то сервер не должен инициировать переустановку. Если флаг
равняется~0 и переустановку инициировал клиент, то серверу РЕКОМЕНДУЕТСЯ
отвергнуть ее.

Если флаг равняется~1, то сервер может переустанавливать связь. Сервер
проверяет расширение \lstinline{renegotiation_info} в сообщении
\lstinline{ClientHello}. Если расширения нет или его содержимое отличается
от \lstinline{client_verify_data}, то сервер ДОЛЖЕН разорвать связь. В
противном случае сервер формирует расширение \lstinline{renegotiation_info}
по \lstinline{server_verify_data}, \lstinline{client_verify_data} и
отправляет его в сообщении \lstinline{ServerHello}.

После переустановки связи сервер должен сохранить новые 
значения \lstinline{client_verify_data} и \lstinline{server_verify_data}. 

\section{Сообщение сервера \lstinline{Certificate}}\label{HANDSHAKE.8}

Сервер ДОЛЖЕН посылать сообщение \lstinline{Certificate} всегда, когда в
согласованном алгоритме формирования общего ключа используются его
сертификаты. Сообщение \lstinline{Certificate} обязательно высылается при
использовании алгоритмов типа DH\_fixed, T,
DHE и T\_PSK. Данное сообщение всегда следует сразу
за сообщением \lstinline{ServerHello}.

Сообщение \lstinline{Certificate} определяется следующим образом:
\begin{lstlisting}
struct {
  ASN.1Cert certificate_list<0..2^24-1>;
} Certificate;
opaque ASN.1Cert<1..2^24-1>;  
\end{lstlisting}

Поле \lstinline{certificate_list} структуры \lstinline{Certificate}
определяет последовательность (цепочку) сертификатов. Непосредственный
сертификат сервера ДОЛЖЕН быть первым в списке. Каждый следующий сертификат
в списке ДОЛЖЕН использоваться для проверки подписи предыдущего. Так как
для признания сертификатов требуется, чтобы открытые ключи корневых
удостоверяющих центров распределялись отдельно, самоподписанный сертификат
корневого удостоверяющего центра может не указываться в цепочке, при
условии, что получатель его уже имеет и может проверить его подлинность.

К сертификатам, отправляемым сервером, применяются следующие правила:
\begin{itemize}
\item[--]
сертификаты ДОЛЖНЫ соответствовать СТБ~34.101.19;

\item[--]
открытый ключ сертификата сервера (первый сертификат в списке) и 
связанные с ключом параметры ДОЛЖНЫ быть совместимы с выбранным 
алгоритмом формирования общего ключа. 
\end{itemize}

\begin{note*}
Для управления выбором сертификатов, могут использоваться 
расширения \lstinline{server_name} и \lstinline{trusted_ca_keys}, 
определенные в~\cite{RFC6066}.
\end{note*} 

Если клиент выслал расширение \lstinline{signature_algorithms} в своем сообщении 
\lstinline{ClientHello}, то все сертификаты, предоставленные сервером, ДОЛЖНЫ быть 
подписаны с использованием пар <<алгоритм хэширования, алгоритмы ЭЦП>> из 
этого расширения. Пары МОГУТ быть различны и сертификат, содержащий 
открытый ключ одного алгоритма ЭЦП, может быть подписан с помощью другого 
алгоритма. Алгоритмы формирования общего ключа не накладывают ограничений 
на алгоритмы подписи сертификатов. Поэтому сертификат может быть подписан 
с помощью любой согласованной пары <<алгоритм хэширования, алгоритмы ЭЦП>>, 
вне зависимости от назначения открытого ключа сертификата. 

Если сервер имеет несколько сертификатов, то он выбирает один из них на 
основе приведенных выше правил. Могут использоваться дополнительные 
правила, учитывающие, например, сетевые адреса сторон протокола, локальную 
конфигурацию, настройки безопасности. Если сервер имеет только один 
сертификат, то ему СЛЕДУЕТ проверить, что сертификат удовлетворяет 
заданным правилам. 

\section{Сообщение \lstinline{ServerKeyExchange}}\label{HANDSHAKE.9}

Сообщение \lstinline{ServerKeyExchange} сервер отправляет после сообщения
\lstinline{Certificate}, если согласование параметров связи выполняется с
сертификатами, или после сообщения \lstinline{ServerHello}, если
сертификаты не используются. Сообщение \lstinline{ServerKeyExchange}
содержит криптографические данные (например, эфемерный открытый ключ), с
помощью которых клиент может сформировать предварительный мастер-ключ
\mbox{\lstinline|pre_master_secret|.}
Сообщение \lstinline{ServerKeyExchange}
должно отправляться тогда и только тогда, когда сообщение сервера
\lstinline{Certificate} содержит недостаточно данных для согласования
\lstinline{pre_master_secret} или это сообщение не отправлялось.

Сообщение \lstinline{ServerKeyExchange} обязательно высылается при
использовании алгоритмов DH\_anon, DHE и
DHE\_PSK, может высылаться при использовании алгоритмов
PSK и T\_PSK и не высылается при использовании
алгоритмов DH\_fixed и T. Формат и содержание
сообщения \lstinline{ServerKeyExchange} определяется в зависимости от
используемого алгоритма.

При определении криптонаборов, которые включают новые алгоритмы
формирования общего ключа, ДОЛЖНО быть сказано, следует ли отправлять
сообщение \lstinline{ServerKeyExchange} и, если сообщение отправлять
следует, ДОЛЖЕН быть определен его формат.

Если клиент выслал расширение \lstinline{signature_algorithms} в своем
сообщении \lstinline{ClientHello}, а сервер при формировании
криптографических данных в \lstinline{ServerKeyExchange} подписывает их, то
при выработке ЭЦП сервер ДОЛЖЕН использовать только те пары <<алгоритм
хэширования, алгоритмы ЭЦП>>, которые были заданы в расширении. Могут быть
противоречия между выбранными клиентом парами и выбранными им
криптонаборами. Поэтому перед выбором криптонабора сервер ДОЛЖЕН проверять
его соответствие присланному расширению \lstinline{signature_algorithms}.

\section{Сообщение \lstinline{CertificateRequest}}\label{HANDSHAKE.10}

Сервер, который предъявил свой сертификат, может запросить сертификат
клиента, если это не противоречит правилам согласованного криптонабора.
Запросом сертификата является сообщение \lstinline{CertificateRequest}. Это
сообщение сервер отправляет либо за \lstinline{ServerKeyExchange}, либо за
\lstinline{ServerHello}, в зависимости от того, высылалось
\lstinline{ServerKeyExchange} или нет.

Сообщение \lstinline{CertificateRequest} определяется следующим образом:
\begin{lstlisting}
struct {
  ClientCertificateType certificate_types<1..2^8-1>;
  SignatureAndHashAlgorithm
    supported_signature_algorithms<2^16-1>;
  DistinguishedName certificate_authorities<0..2^16-1>;
} CertificateRequest;
opaque DistinguishedName<1..2^16-1>;
\end{lstlisting}

Поля структуры \lstinline{CertificateRequest} имеют следующее значение:
\begin{itemize}
\item[--]
\lstinline{certificate_types}~--- 
список методов аутентификации, 
т.~е. типов сертификатов, которые клиенту предлагается предъявить 
(см.~\ref{CRYPTO.3.2}); 

\item[--]
\lstinline{supported_signature_algorithms}~--- список пар <<алгоритм 
хэширования, алгоритмы ЭЦП>>, которые сервер может использовать при проверке 
подписи сертификатов, в порядке убывания приоритета. Тип данного поля 
определяется в~\ref{CRYPTO.3.3};  

\item[--]
\lstinline{certificate_authorities}~--- список отличительных имен 
признаваемых удостоверяющих центров. Формат имен определен в~\cite{X501}. 
Каждое имя в списке кодируется строкой байтов (октетов) по отличительным 
правилам, описанным в СТБ~34.101.19 (приложение~Б). 
Элементы списка могут определять желательные корневые или промежуточные 
удостоверяющие центры и, таким образом, список задает пространство 
доверия. Если список пуст, то клиент МОЖЕТ отправить любой сертификат, тип 
которого указан в \lstinline{certificate_types} (при условии, что у 
клиента нет дополнительных ограничений). 
\end{itemize}

Поля \lstinline{certificate_types} и 
\lstinline{supported_signature_algorithms} структуры 
\lstinline{CertificateRequest} связаны следующими правилами: 
\begin{itemize}
\item[--] 
каждый сертификат, предоставленный клиентом, ДОЛЖЕН быть подписан 
с использованием одной из пар <<алгоритм хэширования, алгоритмы ЭЦП>>, 
указанной в поле \lstinline{supported_signature_algorithms}; 

\item[--]
непосредственный сертификат клиента ДОЛЖЕН иметь тип, включенный 
в \lstinline{certificate_types}. Если ключ сертификата является ключом 
подписи, то он ДОЛЖЕН быть пригоден к использованию с некоторой парой 
<<алгоритм хэширования, алгоритмы ЭЦП>> из поля 
\lstinline{supported_signature_algorithms}. Тип сертификата не 
ограничивает алгоритм, используемый для подписи сертификата. 
\end{itemize}

\begin{note*}
Если сервер, который не предъявил свой сертификат, запрашивает сертификат
клиента, то это считается ошибкой типа  \lstinline{handshake_failure}
(см.~\ref{ALERT.3}).
\end{note*}  

\section{Сообщение \lstinline{ServerHelloDone}}\label{HANDSHAKE.11}

Сообщение \lstinline{ServerHelloDone} сервер отправляет для того, чтобы
известить клиента о завершении пересылки \lstinline{ServerHello} и других
сообщений, нужных для формирования общего ключа. Сообщение означает, что
клиент может приступить к выполнению своей части алгоритма формирования
общего ключа. После отправки \lstinline{ServerHelloDone} сервер ожидает
ответ клиента.

Получив сообщение~\lstinline{ServerHelloDone}, клиенту СЛЕДУЕТ проверить,
что сервер представил действительный сертификат (если сертификат
предоставлялся) и параметры, указанные сервером в \lstinline{ServerHello},
приемлемы.

Сообщение \lstinline{ServerHelloDone} определяется следующим образом:
\begin{lstlisting}
struct {} ServerHelloDone;
\end{lstlisting}

\section{Сообщение клиента \lstinline{Certificate}}\label{HANDSHAKE.12}

Сообщение клиента \lstinline{Certificate} является первым сообщением,
которое клиент посылает серверу после получения от него сообщения
\lstinline{ServerHelloDone}. Сообщение Certificate высылается только тогда,
когда сервер запросил сертификат клиента. Если у клиента нет подходящих
сертификатов, то он ДОЛЖЕН отправить сообщение \lstinline{Certificate} без
сертификатов (поле \lstinline{certificate_list} этого сообщения имеет
нулевую длину).

Если сообщение клиента \lstinline{Certificate} не содержит сертификатов или
некоторый сертификат из списка неприемлем (например, был подписан
недоверенным удостоверяющим центром), то сервер МОЖЕТ, по своему
усмотрению, либо продолжить обмен сообщениями без аутентификации клиента,
либо ответить сигнальным сообщением \lstinline{handshake_failure}.

Формат сообщения \lstinline{Certificate} определен в~\ref{HANDSHAKE.8}. В
этом сообщении клиент передает серверу цепочку сертификатов.
Непосредственный сертификат клиента ДОЛЖЕН быть первым в списке. Сервер
использует переданную цепочку при верификации сообщения
\lstinline{CertificateVerify} (например, если используется алгоритм
формирования общего ключа типа DHE), либо при вычислении
предварительного мастер-ключа (если используется алгоритм формирования
общего ключа типа DH\_fixed).

К сертификатам, отправляемым клиентом, применяются следующие правила:
\begin{itemize}
\item[--]
сертификаты ДОЛЖНЫ соответствовать СТБ~34.101.19;

\item[--]
сертификат клиента (первый сертификат в списке) ДОЛЖЕН иметь один 
из типов, перечисленных в сообщении \lstinline{CertificateRequest}; 

\item[--]
cертификат клиента ДОЛЖЕН соответствовать алгоритму формирования 
общего ключа из согласованного криптонабора и всем согласованным 
расширениям; 

\item[--] 
если список \lstinline{certificate_authorities} в сообщении 
\lstinline{CertificateRequest} не был пустым, то некоторому сертификату в 
цепочке СЛЕДУЕТ быть выпущенным одним из перечисленных удостоверяющих 
центров;  

\item[--] 
сертификаты ДОЛЖНЫ быть подписаны с использованием подходящей 
пары  <<алгоритм хэширования, алгоритмы ЭЦП>>, как это описано 
в~\ref{HANDSHAKE.7}. 
\end{itemize}

\section{Сообщение \lstinline{ClientKeyExchange}}\label{HANDSHAKE.13}

Сообщение \lstinline{ClientKeyExchange} всегда отправляется клиентом. Если
клиент отправляет сообщение \lstinline{Certificate}, то сразу за ним он
ДОЛЖЕН отправить \lstinline{ClientKeyExchange}. В противном случае,
\lstinline{ClientKeyExchange} ДОЛЖНО быть первым сообщением, отправленным
клиентом после того, как он получил \lstinline{ServerHelloDone}.

Сообщение \lstinline{ClientKeyExchange} используется сторонами для
завершения процесса формирования предварительного мастер-ключа
\lstinline{pre_master_secret}. Этот ключ может формировать одна сторона (и
передавать его другой в зашифрованном виде), либо обе стороны могут
участвовать в формировании \lstinline{pre_master_secret}.

Формат \lstinline{ClientKeyExchange} определяется в зависимости от используемого 
алгоритма формирования общего ключа. 

\section{Сообщение \lstinline{CertificateVerify}}\label{HANDSHAKE.14}

Сообщение \lstinline{CertificateVerify} используется для явной верификации
сертификата клиента. Оно посылается только в том случае, когда клиент
представил свой сертификат и открытый ключ этого сертификата может
использоваться в алгоритмах ЭЦП. Сообщение \lstinline{CertificateVerify}
отправляется сразу после сообщения \lstinline{ClientKeyExchange}.

Сообщение \lstinline{CertificateVerify} определяется следующим образом:
\begin{lstlisting}
struct {
  digitally-signed struct {
    opaque handshake_messages[handshake_messages_length];
  }
} CertificateVerify;
\end{lstlisting}

Подписанное поле \lstinline{handshake_messages} содержит все сообщения протокола 
Handshake, отосланные и полученные клиентом, начиная с сообщения 
\lstinline{ClientHello} и заканчивая сообщением, которое предшествует 
\lstinline{CertificateVerify}. Должны учитываться все поля этих сообщений, в том 
числе поля типа и длины. Другими словами, поле \lstinline{handshake_messages} 
представляет собой конкатенацию всех структур протокола Handshake, 
которыми стороны обменялись до отправки сообщения \lstinline{CertificateVerify}.  

Алгоритмы хэширования и ЭЦП, используемые для формирования подписи, ДОЛЖНЫ 
быть указаны в поле \lstinline{supported_signature_algorithms} сообщения 
\lstinline{CertificateRequest}. Кроме того, алгоритмы хэширования и ЭЦП ДОЛЖНЫ быть 
согласованы с открытым ключом сертификата клиента. 

Для того, чтобы сформировать поле \lstinline{handshake_messages} стороны должны либо 
сохранять обработанные сообщения вплоть до \lstinline{CertificateVerify}, либо 
обрабатывать их последовательно с помощью потенциально возможных 
алгоритмов хэширования. Серверы могут минимизировать вычислительные 
затраты, предложив ограниченный набор пар <<алгоритм хэширования, алгоритмы 
ЭЦП>> в сообщении \lstinline{CertificateRequest}. 

\section{Сообщение \lstinline{Finished}}\label{HANDSHAKE.15}
 
Сообщение \lstinline{Finished} всегда высылается сразу после сообщения
\lstinline{ChangeCipherSpec} для подтверждения того, что аутентификация и
формирование общего ключа прошли успешно. Существенно, что сообщение
\lstinline{ChangeCipherSpec} будет получено между другими сообщениями
протокола Handshake и сообщением \lstinline{Finished}. Поэтому
\lstinline{Finished} является первым сообщением, которое защищено с
использованием только что согласованных алгоритмов и ключей. Если сообщению
\lstinline{Finished} не предшествует сообщение
\lstinline{ChangeCipherSpec}, то это является ошибкой.

Получатель сообщения \lstinline{Finished} ДОЛЖЕН проверить, что его
содержимое корректно. Как только одна из сторон отправила свое сообщение
\lstinline{Finished} и подтвердила правильность полученного от другой
стороны сообщения \lstinline{Finished}, она может начать отправлять и
получать данные прикладных протоколов в установленном соединении.

Сообщение \lstinline{Finished} определяется следующим образом: 
\begin{lstlisting}
struct {
  opaque verify_data[verify_data_length];
} Finished;
\end{lstlisting}

Поле \lstinline{verify_data} длины \lstinline{verify_data_length}
формируется с помощью алгоритма генерации  псевдослучайных чисел по
правилу:
\begin{lstlisting}
verify_data = PRF(master_secret, finished_label, 
  Hash(handshake_messages))[0..verify_data_length-1],
\end{lstlisting}
где параметры имеют следующее значение:
\begin{itemize}
\item[--]
\lstinline{finished_label}~--- строка \lstinline{"client finished"} для 
сообщения \lstinline{Finished}, отправленного клиентом, и строка 
\lstinline{"server finished"} для сообщения \lstinline{Finished}, 
отправленного сервером;   

\item[--]
\lstinline{handshake_messages}~--- все данные сообщений протокола 
Handshake (без сообщения \lstinline{HelloRequest}), отправленных и 
полученных стороной, не включая само сообщение \lstinline{Finished}. В 
\lstinline{handshake_messages} содержатся только данные, видимые на уровне 
протокола Handshake (без заголовков протокола 
\lstinline{Record}). Другими словами, \lstinline{handshake_messages}  
представляет собой конкатенацию всех структур протокола 
Handshake, которыми стороны обменялись к данному моменту;

\item[--]
\lstinline{Hash(handshake_messages)}~--- хэш-значение, вычисленное от 
\lstinline{handshake_messages} с помощью алгоритма хэширования, 
используемого в алгоритме генерации псевдослучайных чисел. Если 
криптонабор определяет свой собственный алгоритм генерации псевдослучайных 
чисел, отличный от алгоритма из~\ref{CRYPTO.2.3}, то в криптонаборе ДОЛЖЕН 
быть определен алгоритм хэширования, который используется при формировании 
сообщения \lstinline{Finished}.  
\end{itemize}

Длина поля~\lstinline{verify_data} определяется в зависимости от
криптонабора. В криптонаборе, который явно не определяет значение
\lstinline{verify_data_length}, это значение принимается равным 12. При
разработке криптонаборов МОГУТ определяться другие длины поля
\lstinline{verify_data}, при этом длина ДОЛЖНА быть не меньше 12 байтов.

Значение \lstinline{handshake_messages} содержит в себе все сообщения
протокола Handshake, начиная с сообщения \lstinline{ClientHello} до
сообщения \lstinline{Finished}, не включая последнее. Данное значение может
отличаться от значения \lstinline{handshake_messages} в сообщении
\lstinline{CertificateVerify}, так как \lstinline{handshake_messages} в
сообщении \lstinline{Finished} может дополнительно содержать сообщение
\lstinline{CertificateVerify}. Кроме этого, \lstinline{handshake_messages}
в сообщении \lstinline{Finished} клиента будет отличаться от
\lstinline{handshake_messages} в сообщении \lstinline{Finished} сервера,
так как в сообщении сервера будет  учтено сообщение \lstinline{Finished}
клиента.

Сообщения \lstinline{ChangeCipherSpec}, сигнальные сообщения об ошибках и
любые другие сообщения, которые не являются сообщениями протокола
Handshake, не учитываются при вычислении хэш-значений при
формировании \lstinline{verify_data}. При вычислении хэш-значений
опускаются также сообщения \lstinline{HelloRequest}.

\section{Вычисление мастер-ключа}\label{HANDSHAKE.16}

Мастер-ключ \lstinline{master_secret} определяется по
\lstinline{pre_master_secret}, \lstinline{ClientHello.random} и
\lstinline{ServerHello.random} с помощью алгоритма генерации
псевдослучайных чисел, определенного в~\ref{CRYPTO.2.3}:
\begin{lstlisting}
master_secret = PRF(pre_master_secret, "master secret",
  ClientHello.random + ServerHello.random)[0..47];
\end{lstlisting}

Длина \lstinline{pre_master_secret} может зависеть от используемого алгоритма 
формирования общего ключа, но мастер-ключ всегда состоит из 48 байтов. 

Ключ \lstinline{pre_master_secret} должен быть уничтожен после того, как 
\lstinline{master_secret} вычислен. 



