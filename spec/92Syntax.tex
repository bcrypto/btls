\begin{appendix}{Б}{обязательное}
{Правила описания данных}
\label{SYNTAX}

\hiddensection{Общие соглашения}\label{SYNTAX.1}

Комментарии начинаются с символов <<\lstinline{/*}>> 
и заканчиваются символами <<\lstinline{*/}>>.

Необязательные компоненты заключаются в двойные квадратные скобки: 
<<\lstinline{[[ ]]}>>.

Тип \lstinline{opaque} описывает один байт неструктурированных данных.

Число \lstinline{a} в степени \lstinline{b} обозначается через
\lstinline{a^b}.

\hiddensection{Данные}\label{SYNTAX.2}

Данные, которыми обмениваются стороны протокола TLS, представляют собой 
структурированные объединения элементов. Элементы данных и структуры 
данных в целом представляют собой строки (последовательности) байтов. 
Байты записываются слева направо и сверху вниз. Например, в строке 
\lstinline|{1, 2, 3, 4}| первым байтом является 1, последним~--- 4. 
Длина строки \lstinline|data| обозначается \lstinline{len(data)}. 

Байты строки нумеруются, начиная с 0. Для выделения диапазона байтов с 
номерами от \lstinline|lo| до \lstinline|hi| можно использовать выражение 
\lstinline|[lo..hi]|. Например, строка \lstinline|{1, 2, 3, 4}[1..3]| 
состоит из байтов 2, 3, 4.  

Символом <<\lstinline|+|>> обозначается конкатенация (объединение) строк. 
Например, \lstinline|{1, 2} + {3, 4}| есть \lstinline|{1, 2, 3, 4}|. 

Строка, составленная из байтов со значениями от 32 до 126, может 
представляться строкой символов. Соответствие между символами и байтами 
задает ГОСТ 27463.  Например, строка символов \lstinline|"slithy toves"| 
представляет строку байтов 
\lstinline|{115, 108, 105, 116, 104, 121, 32, 116, 111, 118, 101, 115}|.  

\hiddensection{Векторы}\label{SYNTAX.3}

Вектор~--- это одномерный массив однотипных элементов. Длина вектора может 
быть определена заранее, либо может определяться в момент выполнения 
протокола. В любом случае, длина определяет количество байтов, а не 
количество элементов в векторе. Для определения нового типа \lstinline{T'}, 
представляющего собой вектор фиксированной длины с элементами типа 
\lstinline{T}, используется синтаксис: 
\begin{lstlisting}
T T'[n];
\end{lstlisting}

Здесь \lstinline{T'} занимает \lstinline{n} байтов, где \lstinline{n} 
кратно длине элемента типа \lstinline{T}. Длина вектора не записывается в 
поток данных.  

В следующем примере тип \lstinline{Datum} определяет тройку неструктурированных
байтов, а тип \lstinline{Data}~--- тройку последовательных элементов типа 
\lstinline{Datum}, которые в сумме занимают девять байтов:  
\begin{lstlisting}
opaque Datum[3];
Datum Data[9];
\end{lstlisting}

Векторы переменной длины определяются путем задания диапазона допустимых 
длин (включая границы) с помощью обозначения \lstinline{<floor..ceiling>}: 
\begin{lstlisting}
T T'<floor..ceiling>;
\end{lstlisting}

Число \lstinline{floor} задает минимальную длину, 
а~\lstinline{ceiling}~--- максимальную.  

При передаче вектора переменной длины в поток данных записывается сначала 
фактическая длина вектора, а затем его содержимое. Длина представляется 
числом, занимающим столько байтов, сколько требуется для определения 
максимальной длины (т.~е. значения \lstinline{ceiling}). Вектор переменной 
длины, в котором поле фактической длины равняется нулю, соответствует 
пустому вектору. 

В следующем примере вектор типа~\lstinline{mandatory} содержит от~300 
до~400 байтов, а вектор типа~\lstinline{longer} содержит до 800 байтов 
или до 400 элементов типа \lstinline{uint16}:
\begin{lstlisting}
opaque mandatory<300..400>;
uint16 longer<0..800>;
\end{lstlisting}

Вектор \lstinline{mandatory} не может быть пустым. 
Поле его фактической длины занимает два байта (\lstinline{uint16}), 
которых достаточно для  представления значения 400 (см.~\ref{SYNTAX.5}). 
%
Представление вектора~\lstinline{longer} будет включать 
двухбайтовое поле фактической длины, предшествующее вектору. Длина 
вектора должна быть кратна длине его элементов (например, 
17-байтовый вектор из элементов типа \lstinline{uint16} недопустим). 

\hiddensection{Числа}\label{SYNTAX.4}

Элементами данных могут быть неотрицательные целые числа. Тип \lstinline{uint8} 
представляет беззнаковый байт и является базовым числовым типом данных. 
Все числа, которые не укладываются в байт, представляются вектором 
беззнаковых байтов фиксированной длины. При этом первый байт считается 
старшим, последний~--- младшим. Такой порядок байтов называется сетевым или 
от <<старших к младшим>> (big-endian). Например, строке байтов 
\lstinline|{1, 2, 3, 4}|
соответствует число 
$16909060 = 1 * 2^{24} + 2 * 2^{16} + 3 * 2^8 + 4$.

Следующие числовые типы предопределены:
\begin{lstlisting}
uint8 uint16[2];
uint8 uint24[3];
uint8 uint32[4];
uint8 uint64[8];
\end{lstlisting}

Если неотрицательное целое число необходимо представить вектором с 
элементами типа opaque, то число представляются как беззнаковое (без 
дополнительных нулевых старших байтов даже в тех случаях, когда установлен 
старший бит числа). 

\hiddensection{Перечисления}\label{SYNTAX.5}

Тип \lstinline{enum} поддерживает перечисления. Переменная типа \lstinline{enum} 
может принимать только те значения, которые объявлены в определении 
перечисления. Каждое такое определение задает новый тип. Только переменные 
одного и того же перечислительного типа могут присваиваться друг другу или 
сравниваться между собой. Элементам перечисления должны назначаться числовые 
значения:
\begin{lstlisting}
enum {e1(v1), e2(v2) [[,...]] [[, (n)]]} Te;
\end{lstlisting}

Здесь \lstinline{e1}, \lstinline{e2},\ldots~--- имена элементов, 
\lstinline{v1}, \lstinline{v2},\ldots~--- назначенные значения. Так как 
элементы перечисления не упорядочены, им могут назначаться любые 
уникальные значения и в любом порядке. 

Если в определении перечисления есть многоточие, то перечисление может 
дополняться новыми элементами. Добавление элементов обозначается 
следующим образом: 
\begin{lstlisting}
Te += {e3(v3), e4(v4)};
\end{lstlisting}

\begin{note*}
Возможность доопределения перечислительного типа является 
единственным расширением правил описания данных, заданных в \cite{RFC5246}. 
\end{note*}

Для перечислений, которые никогда не преобразовываются во внешние 
представления, числовые значения могут опускаться. Например, 
\begin{lstlisting}
enum {low, medium, high} Amount;
\end{lstlisting}

Перечисление занимает столько байтов в потоке данных, сколько необходимо 
для записи максимального из значений его элементов. Элементы следующего 
перечисления занимают один байт:  
\begin{lstlisting}
enum {red(3), blue(5), white(7)} Color;
\end{lstlisting}

Для задания количества байтов, которое будет занимать переменная 
перечислительного типа, можно указывать в перечислении элементы без имени. 
В следующем примере переменные типа Taste будут занимать два байта в 
потоке данных, хотя могут принимать только значения~1, 2 или~4:  
\begin{lstlisting}
enum {sweet(1), sour(2), bitter(4), (32000)} Taste;
\end{lstlisting}

Областью видимости имен элементов перечисления является сам 
перечислительный тип. При ссылке на имя можно указывать этот тип явно или 
опускать его, если он ясен из контекста: 
\begin{lstlisting}
Color color = Color.blue;     /</* задано явно */>/    
Color color = blue;           /</* определяется неявно */>/ 
\end{lstlisting}

\hiddensection{Структурированные типы и варианты}\label{SYNTAX.6}

Примитивные типы могут объединяться в структурированный тип (структуру). 
Структуры могут содержать вложенные структуры. Каждое определение 
структуры задает новый уникальный тип. Синтаксис определения структур 
аналогичен синтаксису языка Си: 
\begin{lstlisting}
struct {
  T1 f1;
T2 f2;
...
Tn fn;
} [[T]];
\end{lstlisting}

При ссылке на элемент структуры указывается тип и имя поля (вложенного 
элемента). Например, \lstinline{T.f2}~--- ссылка на второе поле структуры, 
определенной выше. 

Структуры могут содержать варианты, выбор в которых производится на 
основании некоторой переменной, доступной внутри структуры. На выбор 
варианта указывает ключевое слово \lstinline{select}. Механизм разбора 
вариантов во время выполнения TLS не задается настоящими правилами и 
определяется в конкретной реализации TLS.  
 
Переменная, на основании которой производится выбор варианта, должна иметь 
перечислительный тип. Элементы этого типа определяют возможные варианты 
определения структуры. Для каждого элемента должен быть указан вариант 
выбора. Варианты могут объединяться: например, если два элемента следуют 
сразу друг за другом, то им соответствует один и тот же вариант.  

Для определения вариантов используется следующий синтаксис:
\begin{lstlisting}
struct {
  T1 f1;
  T2 f2;
  ...
  Tn fn;
  select (E) {
    case e1: Te1;
    case e2: Te2;
    case e3: case e4: Te3;
    ...
    case en: Ten;
  } [[fv]];
} [[Tv]];
\end{lstlisting}

Здесь \lstinline{E}~--- перечислительный тип. Для ссылки на вариант ему 
может быть присвоена метка \lstinline{fv}. 

В следующем примере за выбор варианта отвечают переменные 
типа~\lstinline{VariantTag}:  
\begin{lstlisting}
enum {apple, orange, banana} VariantTag;
struct {
  uint16 number;
  opaque string<0..10>; /</* переменная длина */>/
} V1;
struct {
  uint32 number;
  opaque string[10];    /</* фиксированная длина */>/
} V2;
struct {
  select (VariantTag) { /</* значение задано неявно */>/
  case apple:
    V1;                 /</* apple */>/
  case orange:
  case banana:
    V2;                 /</* orange или banana */>/
  } variant_body;       /</* необязательная метка */>/
} VariantRecord;
\end{lstlisting}

\hiddensection{Криптографические атрибуты}\label{SYNTAX.7}

Для указания на криптографическую обработку данных используются 
специальные атрибуты, которые предшествуют описанию типа данных. Ключи, 
которые используются при криптографической обработке, определяются текущим 
состоянием соединения TLS (см.~\ref{RECORD.2}). 

Атрибут \lstinline{digitally-signed} используется для обозначения выходных данных 
алгоритмов выработки ЭЦП. Элемент с атрибутом \lstinline{digitally-signed} 
преобразуется в структуру \lstinline{DigitallySigned}: 
\begin{lstlisting}
struct {
  SignatureAndHashAlgorithm algorithm;
  opaque signature<0..2^16-1>;
} DigitallySigned;
\end{lstlisting}

Здесь поле \lstinline{algorithm} определяет используемую при выработке ЭЦП пару 
<<алгоритм хэширования, алгоритмы ЭЦП>> (см.~\ref{HANDSHAKE.7}). 
Поле \lstinline{signature} определяет значение ЭЦП, выработанное от 
содержимого элемента. Само содержимое элемента не включается в структуру. 
Длина подписи определяется используемым алгоритмом выработки ЭЦП и его ключами. 

Атрибут \lstinline{stream-ciphered} (\lstinline{block-ciphered}) 
указывает, что данные защищены с помощью
алгоритмов поточного (блочного) шифрования. 
Длина данных, которые зашифровываются блочно, должна быть кратна длине блока. 

Атрибут \lstinline{aead-ciphered} указывает, что данные зашифрованы и дополнены 
имитовставкой. Обработка данных выполняется с помощью алгоритмов 
одновременного шифрования и имитозащиты. Входные данные алгоритма могут 
иметь произвольную длину.  

Атрибут \lstinline{public-key-encrypted} используется для обозначения выходных данных 
алгоритмов шифрования с открытым ключом. Данные зашифровываются таким 
образом, что расшифровать их можно только на соответствующем личном ключе. 
Элемент с атрибутом \lstinline{public-key-encrypted} преобразуется в 
следующий вектор переменной длины: 
\begin{lstlisting}
opaque vector <0..2^16-1>; 
\end{lstlisting}

Фактическая длина вектора определяется используемым алгоритмом шифрования 
и его ключами. 

Рассмотрим пример использования криптографических атрибутов:
\begin{lstlisting}
stream-ciphered struct {
  uint8 field1;
  uint8 field2;
  digitally-signed struct {
    uint8 field3<0..255>;
    uint8 field4;
  };
} UserType;
\end{lstlisting}

В этом примере содержимое внутренней структуры (поля \lstinline{field3} и
\lstinline{field4}) используется в качестве входных данных для пары
<<алгоритм хэширования, алгоритмы ЭЦП>>, т.~е. от полей \lstinline{field3}
и \lstinline{field4} вырабатывается ЭЦП. После этого вся структура
\lstinline{UserType} зашифровывается поточно. Длина
зашифрованной структуры будет равна сумме длин полей \lstinline{field1} и
\lstinline{field2} (два байта), поля \lstinline{algorithm}, определяющего
используемые алгоритмы хэширования и ЭЦП (два байта), поля с длиной ЭЦП
(два байта), а также поля, содержащего ЭЦП. Длина ЭЦП известна, так как
известны используемый алгоритм выработки ЭЦП и его ключи.

\hiddensection{Константы}\label{SYNTAX.8}

Элементам данных могут назначаться значения. Для этого должны 
использоваться типизированные константы. Например, 
\begin{lstlisting}
struct {
  uint8 f1;
  uint8 f2;
} Example1;
Example1 ex1 = {1, 4};  /</* f1 = 1, f2 = 4 */>/
\end{lstlisting}

Переменным некоторых типов значения назначены быть не могут. К таким типам 
относятся opaque, структуры, содержащие поля типа opaque, векторы 
переменной длины. 

\end{appendix}

