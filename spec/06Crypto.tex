\chapter{Криптонаборы и методы аутентификации}\label{CRYPTO}\section{Криптонаборы}\label{CRYPTO.1}Криптонабор определяет:\begin{itemize}\item[--] алгоритмы шифрования (зашифрования и расшифрования), которые используются для обеспечения конфиденциальности данных, передаваемых между клиентом и сервером; \item[--] алгоритм имитозащиты, который используется для контроля целостности данных; \item[--]алгоритм генерации псевдослучайных чисел, который используется для генерации ключей и синхропосылок по мастер-ключу, а также для верификации сообщений; \item[--]алгоритм формирования общего ключа, который используется для согласования или передачи предварительного мастер-ключа с последующим построением мастер-ключа. \end{itemize}Включенные в криптонабор алгоритмы шифрования, имитозащиты и генерации псевдослучайных чисел в совокупности составляют криптоопределение. Каждому криптонабору назначается уникальный идентификатор типа \lstinline{CipherSuite}: \begin{lstlisting}uint8 CipherSuite[2];\end{lstlisting}Идентификатор \lstinline|{0, 0}| зарезервирован для криптонабора \lstinline|TLS_NULL_WITH_NULL_NULL|: \begin{lstlisting}CipherSuite TLS_NULL_WITH_NULL_NULL = {0, 0};\end{lstlisting}В этом криптонаборе все алгоритмы являются <<пустыми>> (обозначаются \lstinline{null}), т.~е. не выполняют никаких вычислений. Для <<пустых>> алгоритмов длины ключей, синхропосылок и имитовставок полагаются равными~0.  \section{Алгоритмы криптонаборов}\label{CRYPTO.2}\subsection{Алгоритмы шифрования}\label{CRYPTO.2.1}Для шифрования могут использоваться алгоритмы поточного шифрования, алгоритмы блочного шифрования или алгоритмы одновременного шифрования и имитозащиты. Тип алгоритма задается с помощью перечисления\begin{lstlisting}enum {stream, block, aead} CipherType;\end{lstlisting}Элемент \lstinline{stream} этого перечисления указывает на поточное шифрование, элемент \lstinline|block|~--- на блочное, элемент \lstinline|aead|~--- на одновременное шифрование и имитозащиту.При поточном зашифровании открытый текст побитово суммируется с гаммой (двоичной последовательностью), полученной с помощью ключезависимого генератора псевдослучайных чисел. Гамма может вырабатываться для каждого отдельного фрагмента, передаваемого в рамках соединения, или для всех фрагментов сразу. В первом случае при генерации гаммы должна использоваться синхропосылка, уникальная для обрабатываемого фрагмента (например, номер фрагмента). Во втором случае состояние генератора гаммы должно сохраняться после зашифрования очередного фрагмента и использоваться при зашифровании следующего. При блочном зашифровании каждый блок открытого текста преобразуется в блок шифртекста. Шифрование выполняется в режиме сцепления блоков. Перед зашифрованием открытый текст дополняется незначащими байтами, чтобы получить строку байтов, длина которой кратна длине блока алгоритма. При зашифровании используется синхропосылка, которая передается вместе с шифртекстом. Алгоритмы одновременного шифрования и имитозащиты~--- это алгоритм установки защиты и алгоритм снятия защиты. Алгоритм установки защиты берет на вход ключ, синхропосылку, критические данные, для которых будет обеспечиваться шифрование и имитозащита, и открытые данные, для которых будет обеспечиваться только имитозащита. Алгоритм установки защиты возвращает зашифрованные критические данные и имитовставку открытых и критических данных. Алгоритм снятия защиты берет на вход ключ, синхропосылку, имитовставку, зашифрованные критические данные и открытые данные. Алгоритм снятия защиты либо расшифровывает критические данные, либо возвращает признак нарушения целостности данных. Допустимые алгоритмы шифрования задаются типом \lstinline{BulkCipherAlgorithm}: \begin{lstlisting}enum {null,...} BulkCipherAlgorithm; \end{lstlisting}Элемент \lstinline{null} соответствует <<пустому>> алгоритму шифрования, который не изменяет поступающие на его вход данные. Алгоритм \lstinline{null} классифицируется как алгоритм поточного шифрования. \subsection{Алгоритмы имитозащиты}\label{CRYPTO.2.2}Допустимые алгоритмы имитозащиты задаются типом \lstinline{MACAlgorithm}: \begin{lstlisting}enum {null,...} MACAlgorithm;\end{lstlisting}Элемент \lstinline{null} соответствует <<пустому>> алгоритму имитозащиты, который не вычисляет имитовставку. Если в качестве алгоритмов шифрования выбраны алгоритмы типа \lstinline{aead}, то в качестве алгоритма имитозащиты должен быть выбран \lstinline{null}. \subsection{Алгоритмы генерации псевдослучайных чисел}\label{CRYPTO.2.3}Алгоритм генерации псевдослучайных чисел принимает на вход три параметра, которые обозначаются \lstinline{secret}, \lstinline{label} и \lstinline{seed}, и возвращает строку байтов требуемой длины, которая обозначается \lstinline{PRF(secret, label, seed)}. Входные параметры \lstinline{secret}, \lstinline{label} и \lstinline{seed}~--- это строки байтов произвольной длины, причем \lstinline{label} можно задать строкой символов (см.~\ref{SYNTAX.2}, приложение~\ref{SYNTAX}). Вычисление \lstinline{PRF(secret, label, seed)} состоит в обращении к алгоритму генерации псевдослучвйных чисел в режиме HMAC, определенному в СТБ~34.101.47 (подраздел~\ref{CRYPTO.3}), с передачей \lstinline{secret} в качестве ключа и \lstinline{label + seed} в качестве синхропосылки. Используемый алгоритм СТБ~34.101.47 строится на основе алгоритма HMAC, который, в свою очередь, строится на некотором алгоритме хэширования. Могут использоваться различные базовые алгоритмы хэширования. Используемый алгоритм ДОЛЖЕН однозначно определяться в криптонаборе. СЛЕДУЕТ использовать криптографически стойкие алгоритмы. Выходные данные \lstinline{PRF(secret, label, seed)} формируются блоками по~$n$ байтов, где~$n$~--- длина хэш-значения (определяется используемым алгоритмом хэширования). Для генерации~$m$ байтов следует сформировать~$k$ блоков, где~$k$~--- минимальное целое такое, что $nk\geq m$.  При необходимости в последнем блоке следует отбросить последние байты. Допустимые алгоритмы генерации псевдослучайных чисел задаются типом \lstinline{PRFAlgorithm}: \begin{lstlisting}enum {...} PRFAlgorithm;\end{lstlisting}\subsection{Алгоритмы формирования общего ключа}\label{CRYPTO.2.4}Алгоритм формирования общего ключа является интерактивным. Это значит, чтоего выполняют совместно клиент и сервер, обмениваясь между собойсообщениями, которые содержат промежуточные результаты вычислений.Сообщения алгоритма~--- это сообщения протокола Handshake, описанные в~\ref{HANDSHAKE.3}. По завершении алгоритма стороны формируют предварительный мастер-ключ, известный только им. По этому ключу и случайным данным, вырабатываемым каждой из сторон, строится окончательный мастер-ключ. В криптонаборе, вообще говоря, можно определить любой алгоритм формирования общего ключа. Тем не менее в основной спецификации~\cite{RFC5246} и ее расширении~\cite{RFC4279} описаны семь типов таких алгоритмов, которые покрывают большинство существующих на сегодняшний день решений. Для описания этих типов используются обозначения, близкие к обозначениям СТБ~34.101.45:  $G$~--- элемент аддитивной (алгебраической) группы, который порождает циклическую группу $\langle G \rangle$ порядка $q$; $d_S, d_C \in \{1, 2,\ldots, q - 1\}$~--- личные ключи сервера и клиента соответственно;  $Q_S = d_S G$, $Q_C = d_C G$~--- открытые ключи сторон. {\bf DH\_anon} (протокол Диффи~--~Хеллмана без аутентификации сторон). Сервер в сообщении \lstinline{ServerKeyExchange} переcылает клиенту описание группы $\langle G \rangle$ и свой открытый ключ $Q_S$. Клиент в сообщении \lstinline{ClientKeyExchange} пересылает серверу свой открытый ключ $Q_C$. Стороны вычисляют общий ключ $d_S d_C G = d_S Q_C = d_C Q_S$, по которому строится предварительный мастер-ключ. Сертификаты не используются. {\bf DH\_fixed} (протокол Диффи~--~Хеллмана cо статическим ключом). Сервер в сообщении \lstinline{Certificate} передает свой сертификат, который содержит описание $\langle G \rangle$ и открытый ключ $Q_{S}$. Сообщение \lstinline{ServerKeyExchange} не передается. Клиент в сообщении \lstinline{Certificate} (по запросу сервера) передает в своем сертификате статический (неизменяемый) открытый ключ $Q_{C}$. Если запроса от сервера нет, то клиент передает эфемерный (одноразовый) открытый ключ $Q_{C}$ в сообщении \lstinline{ClientKeyExchange}. Стороны вычисляют общий ключ $d_{S}d_{C}G$, по которому определяется предварительный мастер-ключ. {\bf DHE} (протокол Диффи~--~Хеллмана c эфемерными ключами). Сервер в сообщении \lstinline{Certificate} передает клиенту сертификат, открытый ключ которого можно использовать для проверки ЭЦП. Затем сервер в сообщении \lstinline{ServerKeyExchange} передает описание группы $\langle G \rangle$, свой эфемерный открытый ключ $Q_{S}$ и подписывает эти данные, а также случайные данные обеих сторон, на личном ключе, который соответствует переданному сертификату. Клиент проверяет ЭЦП и в сообщении \lstinline{ClientKeyExchange} передает свой открытый ключ $Q_{C}$. Стороны вычисляют общий ключ $d_{S}d_{C}G = d_{S}Q_{C} = d_{C}Q_{S}$, по которому строится предварительный мастер-ключ.  {\bf T} (транспорт). Сервер в сообщении \lstinline{Certificate} передает свой сертификат, открытый ключ которого можно использовать для шифрования. Клиент выполняет на этом ключе зашифрование предварительного мастер-ключа и передает зашифрованный ключ в сообщении \lstinline{ClientKeyExchange}. Сервер выполняет расшифрование на своем личном ключе. Сообщение \lstinline{ServerKeyExchange} не передается. {\bf PSK} (на основе предварительного распределения секретов, от английского pre-shared key). Клиент и сервер предварительно распределяют между собой набор общих секретов. Клиент выбирает секрет из набора и в сообщении \lstinline{ClientKeyExchange} передает идентификатор выбранного секрета. Для помощи при выборе секрета сервер в \lstinline{ServerKeyExchange} может передать подсказку (например, номер секрета). Если подсказка не нужна, то сообщение \lstinline{ServerKeyExchange} не передается. Предварительный мастер-ключ строится по выбранному секрету. Сертификаты не используются.  {\bf DHE\_PSK} (совмещение PSK и DHE). Сервер в сообщении \lstinline{ServerKeyExchange} передает описание группы $\langle G \rangle$ и свой эфемерный открытый ключ $Q_{S}$. Дополнительно сервер может передать в \lstinline{ServerKeyExchange} PSK-подсказку. Клиент в \lstinline{ClientKeyExchange} передает свой эфемерный открытый ключ $Q_{С}$ и идентификатор выбранного PSK-секрета. Стороны определяют общий ключ Диффи ~--~Хеллмана $d_{S}d_{C}G = d_{S}Q_{C} = d_{C}Q_{S}$ и общий PSK-секрет. Предварительный мастер-ключ является результатом конкатенации этих общих секретных данных. Сертификаты не используются. {\bf T\_PSK} (совмещение PSK и транспорта). Дополнительно к сообщениям механизма PSK, сервер в сообщении \lstinline{Certificate} посылает клиенту свой сертификат, открытый ключ которого можно использовать для шифрования. Клиент выполняет на этом ключе зашифрование предварительного мастер-ключа и передает зашифрованный ключ в сообщении \lstinline{ClientKeyExchange} вместе с идентификатором выбранного PSK-секрета. Сервер выполняет расшифрование на своем личном ключе и объединяет полученный предварительный мастер-ключ с общим PSK-секретом. \begin{note}Описание группы $\langle G \rangle$ может задаваться явно или косвенно. Явное описание задается набором параметров, описывающих структуру группы, ее порядок, правила представления элементов и др. Клиент ДОЛЖЕН проверятькорректность присланного ему явного описания группы $\langle G \rangle$. Косвенное описание задается ссылкой на фиксированные параметры, известные клиенту и серверу, например, на параметры из ТНПА или из сертификата сервера.\end{note}\begin{note}В алгоритмах типа DH\_anon не используются ни сертификаты, ни общие секретные данные и, таким образом, не проверяется подлинность сторон. Поэтому алгоритмы типа DH\_anon не обеспечивают защиту от атак <<противник посередине>>, и их рекомендуется использовать только в специальных случаях.\end{note}\begin{note}В алгоритмах типа DH\_fixed, T при компрометации личного ключа сервера все сообщения предыдущих соединений TLS могут быть раскрыты. Данные алгоритмы не обеспечивают защиту от атак по <<чтению назад>> и их рекомендуется использовать только в специальных случаях. Защиту от <<чтения назад>> не обеспечивают также алгоритмы типа PSK (при компрометации PSK-секрета) и T\_PSK (при компрометации PSK-секрета и личного ключа сервера).\end{note} \begin{note}Алгоритмы типа PSK не обеспечивают защиту от словарных атак по подборуPSK-секрета со стороны злоумышленника, который перехватывает все сообщенияпротокола. Алгоритмы типа DHE\_PSK, Т\_PSK защищают от таких атак, но необеспечивают защиту от словарных атак злоумышленника, который выдает себя засервер (DHE\_PSK) или является таковым (T\_PSK) и пытается узнать PSK-секрет уклиента.\end{note}\begin{note}Если клиент $C$ взаимодействует с сервером $A$, контролируемым злоумышленником,и использует алгоритм формирования общего ключа типа T, то злоумышленник можетпровести атаку, описанную в~\cite{TripleHandshake}. Злоумышленник можеторганизовать защищенное соединение между $C$ и другим сервером $S$,  при котором$С$ и $S$ будут считать, что взаимодействуют с $A$ и не смогут обнаружить, чтовзаимодействуют между собой. СЛЕДУЕТ учитывать возможность данной атаки прииспользовании алгоритмов типа T.\end{note}\section{Методы аутентификации}\label{CRYPTO.3}\subsection{Аутентификация сервера}\label{CRYPTO.3.1}Аутентификация сервера основана, как правило, на проверке сертификата открытого ключа сервера и на проверке владения сервером соответствующим личным ключом. Успешное завершение протокола Handshake означает, что аутентификация завершена успешно: сертификат сервера действителен и сервер действительно владеет личным ключом. В алгоритмах формирования общего ключа на основе предварительно распределенных секретов проводится неявная аутентификация сервера, основанная на проверке владения PSK-секретом. Успешное завершение протокола Handshake означает, что сервер действительно владеет этим секретом. Если секрет распределялся по защищенным каналам только клиенту и серверу, то владение секретом доказывает клиенту подлинность сервера. \subsection{Аутентификация клиента}\label{CRYPTO.3.2}Для аутентификации клиента сервер, как правило, запрашивает его сертификат в сообщении \lstinline{CertificateRequest}. Сертификат должен содержать открытый ключ определенного алгоритма ЭЦП. Сервер указывает в \lstinline{CertificateRequest} список подходящих типов открытых ключей. Данные типы задаются одним байтом и  называются методами аутентификации клиента. Допустимые методы аутентификации клиента задаются типом \lstinline{ClientCertificateType}:\begin{lstlisting}enum {..., (255)} ClientCertificateType;\end{lstlisting}В ответ на запрос сервера клиент представляет сертификат одного из запрашиваемых типов и подписывает на личном ключе, соответствующем открытому ключу сертификата, определенные данные. При этом используется пара <<алгоритм хэширования, алгоритмы ЭЦП>>. Данная пара используется также в некоторых алгоритмах формирования общего ключа. В алгоритмах формирования общего ключа на основе предварительно распределенных секретов проводится неявная аутентификация клиента. При соблюдении мер защиты PSK-секрета успешное завершение Handshake означает, что клиент действительно знает этот секрет, т.~е. является подлинным.  \subsection{Алгоритмы хэширования и электронной цифровой подписи}\label{CRYPTO.3.3}Пара <<алгоритм хэширования, алгоритмы ЭЦП>> задается следующим типом:\begin{lstlisting}struct {  HashAlgorithm hash;  SignatureAlgorithm signature;} SignatureAndHashAlgorithm;\end{lstlisting}Поле \lstinline{hash} определяет алгоритм хэширования и описывается следующим типом:  \begin{lstlisting}enum {none(0),..., (255)} HashAlgorithm;\end{lstlisting}Элемент \lstinline{none} означает, что алгоритмы ЭЦП не требуют хэширования данных перед выработкой или проверкой подписи.  Поле \lstinline{signature} определяет алгоритмы ЭЦП и описывается следующим типом: \begin{lstlisting}enum {anonymous(0),..., (255)} SignatureAlgorithm;\end{lstlisting}Элемент \lstinline{anonymous} означает, что подпись не вырабатывается.