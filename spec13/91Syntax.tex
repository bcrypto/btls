\begin{appendix}{А}{обязательное}{Правила описания данных}\label{SYNTAX}

\hiddensection{Общие соглашения}\label{SYNTAX.Common}

Комментарий начинается парой символов \code{/*} и заканчивается парой символов 
\code{*/}.

Необязательные компоненты окаймляются двойными квадратными скобками: 
\code{[[ ]]}.

Данные описываются типами. Имеются базовые (примитивные) типы, от которых 
порождаются составные.

Данные кодируются последовательностями байтов. Правила кодирования определяются 
типом данных. Байты кодового представления записываются и читаются слева 
направо и сверху вниз.

Базовый тип \code{opaque} описывает один байт неструктурированных данных.

Псевдоним \code{T1} уже введенного типа~\code{T} определяется следующим 
образом:
%
\begin{codeblock}
T T1;
\end{codeblock}

\hiddensection{Числа}\label{SYNTAX.Numbers}

Целые числа от~$0$ до~$255$, беззнаковые байты, описываются типом \code{uint8}. 

Порожденные от \code{uint8} типы (векторы элементов \code{uint8}, 
см.~\ref{SYNTAX.Vectors}):
%
\begin{codeblock}
uint8 uint16[2];
uint8 uint24[3];
uint8 uint32[4];
uint8 uint64[8];
\end{codeblock}

Они также описывают беззнаковые числа, кодируя их последовательностями 
байтов фиксированной длины. 
%
Используются соглашения <<от старших к младшим>> (big-endian): первый байт 
считается старшим байтом числа, последний~--- младшим.

Числа записываются либо в десятичном, либо в шестнадцатеричном виде.
Признаком шестнадцатеричной записи является префикс \code{0x}.
%
Например, \code{0x01020304}~--- это шестнадцатеричная запись числа 
$16909060=1\cdot 2^{24}+2\cdot 2^{16}+3\cdot 2^8+4$. При этом число 
кодируется байтами \code{0x01}, \code{0x02}, \code{0x03}, \code{0x04}.

Число \code{a} в степени \code{b} обозначается через \code{a^b}.

\hiddensection{Векторы}\label{SYNTAX.Vectors}

Вектор~--- это одномерный массив однотипных элементов. Длина вектора 
определяется либо заранее, либо в момент кодирования. В любом случае длина 
определяет размер вектора в байтах, а не число элементов в векторе. 

Тип~\code{T2}, который описывает векторы фиксированной длины с элементами 
типа~\code{T}, определяется следующим образом:
%
\begin{codeblock}
T T2[n];
\end{codeblock}
%
Здесь \code{n}~--- размер векторов \code{T2} в байтах. Предполагается, что коды 
элементов \code{T} имеют фиксированную длину, и что число~\code{n} кратно этой длине. 

При кодировании векторов фиксированной длины длина не включается в кодовое представление. 

В следующем примере тип \code{Datum} описывает тройку неструктурированных
байтов, а тип \code{Data}~--- тройку элементов типа \code{Datum}, которые в 
сумме занимают 9 байт:
%
\begin{codeblock}
opaque Datum[3];
Datum Data[9];
\end{codeblock}

Векторы переменной длины описываются путем задания диапазона допустимых 
длин (включая границы) с помощью обозначения \code{<floor..ceiling>}: 
%
\begin{codeblock}
T T3<floor..ceiling>;
\end{codeblock}
%
Число \code{floor} задает минимальную длину, \code{ceiling}~--- максимальную.  

В кодовом представлении вектора переменной длины указывается сначала 
фактическая длина вектора, а затем его содержимое. Код длины занимает
столько же байтов, сколько требуется для кодирования числа~\code{ceiling}. 
%
Вектор переменной длины, актуальная длина которого равняется нулю, 
кодируется пустой последовательностью. 

В следующем примере вектор типа~\code{mandatory} содержит от~300 
до 400~байт, а вектор типа~\code{longer}~--- до 800~байт или до 400~элементов 
типа~\code{uint16}: 
%
\begin{codeblock}
opaque mandatory<300..400>;
uint16 longer<0..800>;
\end{codeblock}
%
Вектор~\code{mandatory} не может быть пустым. Код его длины занимает 2~байта, 
которых достаточно для представления числа~400 (см.~\ref{SYNTAX.Numbers}).
%
Вектор~\code{longer} может иметь нулевую длину, и тогда его кодовое
представление~--- это пустая последовательность.
%
Если же длина ненулевая, то кодовое представление вектора начинается с кода
длины, и этот код снова является двухбайтовым.

\hiddensection{Перечисления}\label{SYNTAX.Enums}

Тип, определяемый с помощью ключевого слова \code{enum}, описывает 
перечисление. Переменные типа принимают неотрицательные целые значения, причем 
только те, которые объявлены в определении типа. Этим значениям назначаются 
имена. Сравнение и присваивание должны выполняться в рамках одного типа.

В следующем примере тип \code{Te} задает использование значений 
\code{v1}, \code{v2}, \ldots, \code{vn} с именами 
\code{e1}, \code{e2}, \ldots, \code{en}:
\begin{codeblock}
enum { e1(v1), e2(v2), ..., en(vn) [[, (m)]] } Te;
\end{codeblock}

Перечень допустимых значений и соответствующих имен перечислительного типа 
может дополняться. Дополнение задается оператором \code{+=}:
\begin{codeblock}
Te += {ee(vv), eee(vvv)};
\end{codeblock}

\begin{note*}
Использование оператора \code{+=} является расширением правил описания данных, 
заданных в \cite{RFC8446}.
\end{note*}

В определении перечислительного типа может фигурировать максимальное допустимое 
значение. Оно указывается без имени и используется при определении длины 
кодового представления элементов типа. В примере с \code{Te} таким значением 
является \code{m}.

Код переменной перечислительного типа занимает столько байтов, сколько 
необходимо для записи максимального допустимого значения. Элементы следующего 
перечисления занимают 1~байт:
%
\begin{codeblock}
enum { red(3), blue(5), white(7) } Color;
\end{codeblock}

Максимальное допустимое значение может быть указано в определении типа без 
введения соответствующего элемента, т.~е. без имени. В примере с типом~\code{Te} 
таким значением является \code{m}. 

В следующем примере коды переменных типа \code{Taste} будут занимать 2~байта, 
хотя могут принимать только значения~1, 2 или~4: 
%
\begin{codeblock}
enum { sweet(1), sour(2), bitter(4), (32000) } Taste;
\end{codeblock}

Областью видимости имен элементов перечисления является сам 
перечислительный тип. При ссылке на имя можно указывать этот тип явно или 
опускать его, если он ясен из контекста: 
%
\begin{codeblock}
Color color = Color.blue;     /</* задано явно */>/
Color color = blue;           /</* определяется неявно */>/
\end{codeblock}

Имена, назначаемые элементам перечислительного типа, не обязательно должны 
быть уникальны, имя может быть назначено целому диапазону значений.
Диапазон задается минимальной и максимальной границами, разделенными двумя 
точками:
%
\begin{codeblock}
enum { sad(0), meh(1..254), happy(255) } Mood;
\end{codeblock}

\hiddensection{Структуры}\label{SYNTAX.Structs}

Примитивные типы могут объединяться в составные типы~--- структуры. 
Синтаксис определения структур аналогичен синтаксису языка Си: 
%
\begin{codeblock}
struct {
  T1 f1;
  T2 f2;
  ...
  Tn fn;
} T;
\end{codeblock}

В структуры могут быть вложены другие структуры, векторы фиксированной и 
переменной длин. Структуры~\code{V1} и~\code{V2} в примерах 
раздела~\ref{SYNTAX.Variants} это демонстрируют.

При ссылке на поле структуры указываются тип и имя поля. Например, 
\lstinline{T.f2}~--- ссылка на второе поле структуры, определенной выше.

Кодовое представление переменной составного типа представляет собой
объединение кодов ее последовательных полей.

\hiddensection{Константы}\label{SYNTAX.Consts}

Полям структур и переменным могут назначаться значения. Оператор присваивания 
обозначается знаком \code{=}. Например,
% 
\begin{codeblock}
struct {
  T1 f1 = 8;  /</* T.f1 всегда равняется 8 */>/
  T2 f2;
} T;
\end{codeblock}

\hiddensection{Варианты}\label{SYNTAX.Variants}

Структура может иметь разные варианты построения. Выбор варианта
производится на основании дополнительной информации, которая оговаривается
при описании структуры за рамками данных правил.

Переменная, на основании которой производится выбор варианта, должна иметь
перечислительный тип. Переключение между вариантами описывается с помощью 
ключевого слова \code{select}. По каждой ветке~\code{select} указывается 
тип, соответствующий варианту построения, и, возможно, имя поля данного типа:
%
\begin{codeblock}
struct {
  T1 f1;
  T2 f2;
  ...
  Tn fn;
  select (E) {
    case e1: Te1 [[fe1]];
    case e2: Te2 [[fe2]];
    ...
    case en: Ten [[fen]];
  };
} Tv;
\end{codeblock}

В следующем примере за выбор варианта в структуре~\code{VariantRecord}
отвечает переменная перечислительного типа~\code{VariantTag}:
%
\begin{codeblock}
enum { apple(0), orange(1) } VariantTag;

struct {
  uint16 number;
  opaque string<0..10>;   /</* переменная длина */>/
} V1;

struct {
  uint32 number;
  opaque string[10];      /</* фиксированная длина */>/
} V2;

struct {
  VariantTag type;
  select (VariantRecord.type) {
    case apple:  V1;
    case orange: V2;
  };
} VariantRecord;
\end{codeblock}

\end{appendix}
