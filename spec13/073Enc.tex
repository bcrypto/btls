\section{Защита записей}\label{RECORD.Enc}

При защите записей структура \code{TLSPlaintext} преобразуется 
в структуру \code{TLSCiphertext}. При снятии защиты выполняется обратное 
преобразование.
%
Для защиты используются алгоритмы аутентифицированного шифрования с 
ассоциированными данными (Authenticated Encryption with Associated Data, AEAD).
%
Алгоритм установки защиты принимает на вход открытый текст, открытые 
ассоциированные данные, ключ и синхропосылку и возвращает аутентифицированный 
шифртекст. В качестве последнего обычно выступают собственно шифртекст и 
сопровождающая его имитовставка. 
%
Алгоритм снятия защиты принимает на вход аутентифицированный шифртекст, открытые 
ассоциированные данные, ключ и синхропосылку и возвращает либо открытый текст, 
либо признак ошибки. Ошибка означает нарушение целостности входных данных. 

Аутентифицированный шифртекст обычно имеет б\'{о}льший объем, чем 
соответствующий открытый текст. Должны использоваться такие алгоритмы 
аутентифицированного шифрования, которые расширяют открытый текст не более чем 
на~255 байтов.

При установке защиты структуры \code{TLSPlaintext} открытый текст оформляется  
в виде структуры типа \code{TLSInnerPlaintext}. Этот тип определяется 
следующим образом:
%
\begin{codeblock}
struct {
  opaque content[TLSPlaintext.length];
  ContentType type;
  uint8 zeros[length_of_padding];
} TLSInnerPlaintext;
\end{codeblock}

Поля~\code{TLSInnerPlaintext} имеют следующее значение:
\begin{itemize}
\item
\code{content}~--- \code{TLSPlaintext.fragment}, фрагмент защищаемой записи;

\item
\code{type}~--- \code{TLSPlaintext.type}, тип защищаемой записи;

\item
\code{zeros}~--- нулевые байты, которые маскируют \code{TLSPlaintext.length}. 
Разрешается дописывать произвольное число нулевых байтов при условии, что 
размер структуры \code{TLSInnerPlaintext} остается в пределах ограничений,
установленных в~\ref{RECORD.Pad}.
\end{itemize}

Защищенная запись описывается типом \code{TLSCiphertext}, который
определяется следующим образом:
\begin{codeblock}
struct {
  ContentType opaque_type = application_data;
  ProtocolVersion legacy_record_version = 0x0303;
  uint16 length;
  opaque encrypted_record[TLSCiphertext.length];
} TLSCiphertext;
\end{codeblock}

Поля~\code{TLSCiphertext} имеют следующее значение:
\begin{itemize}
\item
\code{opaque_type}~--- маскировочный тип, который всегда устанавливается
равным \code{application_data} (23). Выбранное значение обеспечивает
максимальную совместимость с промежуточными сетевыми устройствами,
ориентированными на работу с предыдущими версиями TLS. Фактический тип
защищенной записи определяется по полю \code{TLSInnerPlaintext.type} после
снятия защиты;

\item
\code{legacy_record_version}~--- устаревшее поле, в котором должен быть 
задан номер \code{0x0303};

\begin{note*}
В поле указывается версия записей TLS. Поскольку записи TLS версии 1.3 могут 
пересылаться только после того, как данная версия согласована в Handshake, 
проблемы с совместимостью не возникают. Поскольку версия TLS согласована в 
Handshake, поле является избыточным.
\end{note*}

\item
\code{length}~--- длина в байтах поля \code{TLSCiphertext.encrypted_record}, 
следующего за данным. Длина представляет собой сумму длины открытого текста
(включая содержимое, тип и нулевые байты дополнения) и длины его 
расширения при аутентифицированном шифровании. Поле \code{length}  
не должно превышать $2^{14}+256$. При нарушении этого условия принимающая 
сторона должна разорвать соединение с оповещением 
\token[ALERT.Err.ro]{record_overflow};

\item
\code{encrypted_record}~--- шифртекст, полученный в результате 
защиты~\code{TLSInnerPlaintext}.
\end{itemize}

При установке защиты \code{TLSInnerPlaintext} в качестве открытого текста 
выступает конкатенация полей \code{content}, \code{type} и \code{zeros}.
%
Ассоциированными данными является конкатенация трех 
полей~\code{TLSCiphertext}: \code{opaque_type}, \code{legacy_record_version}
и \code{length}.
%
Используется ключ \code{client_write_key} или \code{server_write_key}, который 
определяется по правилам, заданным в~\ref{CRYPTO.TKeys}. Если 
отправителем записи является клиент, то используется ключ 
\code{client_write_key}, если сервер~--- ключ \code{server_write_key}.
%
Синхропосылка строится по правилам, заданным в~\ref{RECORD.Nonce}.

Защита снимается с \code{TLSCiphertext.encrypted_record} с теми же 
ассоциированными данными, ключом и синхропосылкой.
%
В случае ошибки при снятии защиты соединение должно быть разорвано с 
оповещением \token[ALERT.Err.brm]{bad_record_mac}.
