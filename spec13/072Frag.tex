\section{Фрагментация}\label{RECORD.Frag}

Запись содержит фрагмент данных из $2^{14}$ или менее байтов. Длины фрагментов
формируются с учетом типа записей, т.~е. протокола верхнего уровня, который
использует Record для передачи своих сообщений. Определения новых типов следует
сопровождать соглашениями о длинах.

Сообщения Handshake могут передаваться в одной или нескольких записях.
Должны соблюдаться следующие ограничения:
%
\begin{itemize}[label=--]
\item
если сообщение Handshake передается в двух или более записях, то между этими 
записями не должно быть записей других типов; 

% skip: Handshake messages MUST NOT be interleaved with other record types.

\item 
сообщение, которое непосредственно предшествует изменению ключей, должно 
заканчиваться на границе записи. Это условие должно проверяться при приеме 
записей. При нарушении условия соединение должно быть разорвано с оповещением 
\token[ALERT.Err.um]{unexpected_message}. Ограничение распространяется на 
сообщения \token[HS.CH]{ClientHello}, \token[HS.EOED]{EndOfEarlyData}, 
\token[HS.SH]{ServerHello}, \token[HS.F]{Finished} и 
\token[HS.KU]{KeyUpdate}, которые могут непосредственно предшествовать 
изменению ключей;

\item 
фрагмент сообщения Handshake не должен иметь нулевую длину, 
даже если он сопровождается дополнением.
\end{itemize}

Сообщения протокола Alert не должны передаваться в нескольких записях и,
наоборот, в одной записи не должно передаваться несколько сообщений Alert.
Другими словами, запись Alert должна содержать ровно одно сообщение.

Данные прикладных протоколов непрозрачны для TLS. Данные могут передаваться 
в одной или нескольких записях. Записи прикладных протоколов всегда защищены. 
Записи могут содержать фрагменты нулевой длины, что позволяет защищаться от 
анализа трафика (см.~\ref{RECORD.Pad}).

% use: https://www.rfc-editor.org/errata/eid5874

Записи TLS описываются типом~\code{TLSPlaintext}, который определяется 
следующим образом:
\begin{codeblock}
enum {
  invalid(0),
  change_cipher_spec(20),
  alert(21),
  handshake(22),
  application_data(23),
  (255)
} ContentType;

struct {
  ContentType type;
  ProtocolVersion legacy_record_version;
  uint16 length;
  opaque fragment[TLSPlaintext.length];
} TLSPlaintext;
\end{codeblock}

Поля~\code{TLSPlaintext} имеют следующее значение:
\begin{itemize}
\item
\code{type}~--- тип записи (см.~\ref{RECORD.Rec});

\item
\code{legacy_record_version}~--- устаревшее поле, которое должно игнорироваться 
после получения и проверки. 
%
Если в записи передается первое сообщение \token[HS.CH]{ClientHello} протокола 
Handshake, то в поле может указываться номер \code{0x0301}.
%
Во всех остальных случаях в поле должен быть установлен номер \code{0x0303};

\begin{note*}
Номер \code{0x0301} соответствует TLS 1.0, номер \code{0x0303}~--- TLS 1.2.
Установка номера \code{0x0301} в записи для первого \token[HS.CH]{ClientHello}  
и номера \code{0x0303} в записи для повторного \token[HS.CH]{ClientHello} или 
\token[HS.SH]{ServerHello} обеспечивает максимальную совместимость 
с предыдущими версиями TLS.
%
% skip: This document describes TLS 1.3, which uses the version 0x0304. 
\end{note*}

\item
\code{length}~--- длина (в байтах) поля \code{TLSPlaintext.fragment}. 
Длина не должна быть больше $2^{14}$. При получении записи с б\'{о}льшей длиной 
протокол должен быть прерван с оповещением 
\token[ALERT.Err.ro]{record_overflow};

\item
\code{fragment}~--- фрагмент данных. Обрабатывается протоколом верхнего уровня, 
который определяется по полю \code{type}.
\end{itemize}

Структуры \code{TLSPlaintext} пересылаются между сторонами, если не включена 
защита записей. Если защита включена, то структуры защищаются перед отправкой. 
Правила защиты определяются в~\ref{RECORD.Enc}.
